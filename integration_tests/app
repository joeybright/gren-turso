#!/usr/bin/env node

if (parseInt(process.versions.node.split('.')[0]) < 20) {
  throw new Error("This program requires Node v20 or later to run")
}

try {
(function(scope){
'use strict';

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}

function F2(fun) {
  return F(2, fun, function(a) { return function(b) { return fun(a,b); }; })
}
function F3(fun) {
  return F(3, fun, function(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  });
}
function F4(fun) {
  return F(4, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  });
}
function F5(fun) {
  return F(5, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  });
}
function F6(fun) {
  return F(6, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  });
}
function F7(fun) {
  return F(7, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  });
}
function F8(fun) {
  return F(8, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  });
}
function F9(fun) {
  return F(9, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  });
}

function A2(fun, a, b) {
  return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
}
function A3(fun, a, b, c) {
  return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
}
function A4(fun, a, b, c, d) {
  return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e) {
  return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f) {
  return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g) {
  return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h) {
  return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i) {
  return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}



var _Array_length = function (array) {
  return array.length;
};

var _Array_initialize = F3(function (size, offset, func) {
  var result = new Array(size);

  for (var i = 0; i < size; i++) {
    result[i] = func(offset + i);
  }

  return result;
});

var _Array_get = F2(function (index, array) {
  var value = array.at(index);

  if (typeof value === "undefined") {
    return $gren_lang$core$Maybe$Nothing;
  }

  return $gren_lang$core$Maybe$Just(value);
});

var _Array_set = F3(function (index, value, array) {
  try {
    return array.with(index, value);
  } catch (e) {
    // assuming RangeError
    return array;
  }
});

var _Array_splice0 = F3(function (index, toRemove, array) {
  return array.toSpliced(index, toRemove);
});

var _Array_splice1 = F4(function (index, toRemove, toAdd, array) {
  return array.toSpliced(index, toRemove, toAdd);
});

var _Array_spliceN = F4(function (index, toRemove, toAdd, array) {
  return array.toSpliced(index, toRemove, ...toAdd);
});

var _Array_foldl = F3(function (func, acc, array) {
  for (var i = 0; i < array.length; i++) {
    acc = A2(func, array[i], acc);
  }

  return acc;
});

var _Array_foldr = F3(function (func, acc, array) {
  for (var i = array.length - 1; i >= 0; i--) {
    acc = A2(func, array[i], acc);
  }

  return acc;
});

var _Array_indexedFoldl = F3(function (func, acc, array) {
  for (var i = 0; i < array.length; i++) {
    acc = A3(func, i, array[i], acc);
  }

  return acc;
});

var _Array_indexedFoldr = F3(function (func, acc, array) {
  for (var i = array.length - 1; i >= 0; i--) {
    acc = A3(func, i, array[i], acc);
  }

  return acc;
});

var _Array_map = F2(function (func, array) {
  return array.map(func);
});

var _Array_indexedMap = F2(function (func, array) {
  return array.map(function (value, index) {
    return A2(func, index, value);
  });
});

var _Array_filter = F2(function (func, array) {
  return array.filter(func);
});

var _Array_indexedFilter = F2(function (func, array) {
  return array.filter(function (value, index) {
    return A2(func, index, value);
  });
});

var _Array_flat = function (array) {
  return array.flat();
};

var _Array_flatMap = F2(function (func, array) {
  return array.flatMap(func);
});

var _Array_slice = F3(function (from, to, array) {
  return array.slice(from, to);
});

var _Array_append = F2(function (left, right) {
  return left.concat(right);
});

var _Array_reverse = function (array) {
  return array.toReversed();
};

var _Array_findFirst = F2(function (pred, array) {
  for (var i = 0; i < array.length; i++) {
    var element = array[i];

    if (pred(element)) {
      return $gren_lang$core$Maybe$Just({ index: i, value: element });
    }
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _Array_findLast = F2(function (pred, array) {
  for (var i = array.length - 1; i >= 0; i--) {
    var element = array[i];

    if (pred(element)) {
      return $gren_lang$core$Maybe$Just({ index: i, value: element });
    }
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _Array_map2 = F3(function (fn, as, bs) {
  var result = [];
  var lowestLength = as.length < bs.length ? as.length : bs.length;

  for (var i = 0; i < lowestLength; i++) {
    result.push(A2(fn, as[i], bs[i]));
  }

  return result;
});

var _Array_map3 = F4(function (fn, as, bs, cs) {
  var result = [];
  var lowestLength = [as.length, bs.length, cs.length].sort()[0];

  for (var i = 0; i < lowestLength; i++) {
    result.push(A3(fn, as[i], bs[i], cs[i]));
  }

  return result;
});

var _Array_sort = function (array) {
  return array.toSorted(function (a, b) {
    return _Utils_cmp(a, b);
  });
};

var _Array_sortBy = F2(function (fn, array) {
  return array.toSorted(function (a, b) {
    return _Utils_cmp(fn(a), fn(b));
  });
});

var _Array_sortWith = F2(function (fn, array) {
  return array.toSorted(function (a, b) {
    var ord = A2(fn, a, b);
    return ord === $gren_lang$core$Basics$EQ ? 0 : ord === $gren_lang$core$Basics$LT ? -1 : 1;
  });
});

class _Array_Builder {
  constructor(target, finalized, array) {
    this.target = target;
    this.finalized = finalized;
    this.array = array;
  }
}

var _Array_emptyBuilder = function (capacity) {
  return new _Array_Builder(0, false, new Array(capacity));
};

var _Array_pushToBuilder = F2(function (value, builder) {
  var array = builder.array;
  var target = builder.target;

  if (builder.finalized) {
    array = array.slice(0, target);
  } else {
    builder.finalized = true;
  }

  if (target < array.length) {
    array[target] = value;
  } else {
    array.push(value);
  }

  return new _Array_Builder(target + 1, false, array);
});

var _Array_appendToBuilder = F2(function (array, builder) {
  var newArray = _Array_fromBuilder(builder);

  for (var i = 0; i < array.length; i++) {
    newArray.push(array[i]);
  }

  return new _Array_Builder(newArray.length, false, newArray);
});

var _Array_toBuilder = function (array) {
  return new _Array_Builder(array.length, true, array);
};

var _Array_fromBuilder = function (builder) {
  var result = builder.array;

  if (builder.finalized) {
    result = result.slice(0, builder.target);
  } else {
    builder.finalized = true;
    result.length = builder.target;
  }

  return result;
};


// EQUALITY

function _Utils_eq(x, y) {
  for (
    var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack);
    isEqual && (pair = stack.pop());
    isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)
  ) {}

  return isEqual;
}

function _Utils_eqHelp(x, y, depth, stack) {
  if (x === y) {
    return true;
  }

  if (typeof x !== "object" || x === null || y === null) {
    typeof x === "function" && _Debug_crash(5);
    return false;
  }

  if (depth > 100) {
    stack.push({ a: x, b: y });
    return true;
  }

  /**/
	if (x.$ === 'Set_gren_builtin')
	{
		x = $gren_lang$core$Set$toArray(x);
		y = $gren_lang$core$Set$toArray(y);
	}
	if (x.$ === 'RBNode_gren_builtin' || x.$ === 'RBEmpty_gren_builtin')
	{
		x = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], x);
		y = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], y);
	}
	//*/

  /**_UNUSED/
	if (x.$ < 0)
	{
		x = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], x);
		y = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], y);
	}
	//*/

  if (x instanceof DataView) {
    var length = x.byteLength;

    if (y.byteLength !== length) {
      return false;
    }

    for (var i = 0; i < length; ++i) {
      if (x.getUint8(i) !== y.getUint8(i)) {
        return false;
      }
    }

    return true;
  }

  if (x instanceof _Array_Builder) {
    x = _Array_fromBuilder(x);
    y = _Array_fromBuilder(y);
  }

  if (Array.isArray(x) && x.length !== y.length) {
    return false;
  }

  var nextDepth = depth + 1;

  for (var key in x) {
    if (!_Utils_eqHelp(x[key], y[key], nextDepth, stack)) {
      return false;
    }
  }

  return true;
}

var _Utils_equal = F2(_Utils_eq);
var _Utils_notEqual = F2(function (a, b) {
  return !_Utils_eq(a, b);
});

// COMPARISONS

// Code in Generate/JavaScript.hs, Basics.js, and depends on
// the particular integer values assigned to LT, EQ, and GT.

function _Utils_cmp(x, y) {
  if (typeof x !== "object") {
    return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;
  }

  /**/
	if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b ? 0 : a < b ? -1 : 1;
	}
	//*/

  // At this point, we can only be comparing arrays
  for (var idx = 0; idx < x.length; idx++) {
    var ord = _Utils_cmp(x[idx], y[idx]);
    if (ord !== 0) return ord;
  }

  return x.length - y.length;
}

var _Utils_lt = F2(function (a, b) {
  return _Utils_cmp(a, b) < 0;
});
var _Utils_le = F2(function (a, b) {
  return _Utils_cmp(a, b) < 1;
});
var _Utils_gt = F2(function (a, b) {
  return _Utils_cmp(a, b) > 0;
});
var _Utils_ge = F2(function (a, b) {
  return _Utils_cmp(a, b) >= 0;
});

var _Utils_compare = F2(function (x, y) {
  var n = _Utils_cmp(x, y);
  return n < 0 ? $gren_lang$core$Basics$LT : n ? $gren_lang$core$Basics$GT : $gren_lang$core$Basics$EQ;
});

// COMMON VALUES

function _Utils_chr_UNUSED(c) {
  return c;
}
function _Utils_chr(c) {
  return new String(c);
}

// RECORDS

function _Utils_update(oldRecord, updatedFields) {
  var newRecord = {};

  for (var key in oldRecord) {
    newRecord[key] = oldRecord[key];
  }

  for (var key in updatedFields) {
    newRecord[key] = updatedFields[key];
  }

  return newRecord;
}

// APPEND

var _Utils_append = F2(_Utils_ap);

function _Utils_ap(xs, ys) {
  // append Strings
  if (typeof xs === "string") {
    return xs + ys;
  }

  return xs.concat(ys);
}


// LOG

var _Debug_log_UNUSED = F2(function (tag, value) {
  return value;
});

var _Debug_log = F2(function (tag, value) {
  console.log(tag + ": " + _Debug_toString(value));
  return value;
});

// TODOS

function _Debug_todo(moduleName, region) {
  return function (message) {
    _Debug_crash(8, moduleName, region, message);
  };
}

function _Debug_todoCase(moduleName, region, value) {
  return function (message) {
    _Debug_crash(9, moduleName, region, value, message);
  };
}

// TO STRING

function _Debug_toString_UNUSED(value) {
  return "<internals>";
}

function _Debug_toString(value) {
  return _Debug_toAnsiString(false, value);
}

function _Debug_toAnsiString(ansi, value) {
  if (value == null) {
    return _Debug_internalColor(ansi, "<null>");
  }

  if (typeof value === "function") {
    return _Debug_internalColor(ansi, "<function>");
  }

  if (typeof value === "boolean") {
    return _Debug_ctorColor(ansi, value ? "True" : "False");
  }

  if (typeof value === "number") {
    return _Debug_numberColor(ansi, value + "");
  }

  if (value instanceof String) {
    return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
  }

  if (typeof value === "string") {
    return _Debug_stringColor(
      ansi,
      '"' + _Debug_addSlashes(value, false) + '"',
    );
  }

  if (Array.isArray(value)) {
    var output = "[";

    value.length > 0 && (output += _Debug_toAnsiString(ansi, value[0]));

    for (var idx = 1; idx < value.length; idx++) {
      output += ", " + _Debug_toAnsiString(ansi, value[idx]);
    }

    return output + "]";
  }

  if (typeof value === "object" && "$" in value) {
    var tag = value.$;

    if (typeof tag === "number") {
      return _Debug_internalColor(ansi, "<internals>");
    }

    if (tag === "Set_gren_builtin") {
      return (
        _Debug_ctorColor(ansi, "Set") +
        _Debug_fadeColor(ansi, ".fromArray") +
        " " +
        _Debug_toAnsiString(ansi, $gren_lang$core$Set$toArray(value))
      );
    }

    if (tag === "RBNode_gren_builtin" || tag === "RBEmpty_gren_builtin") {
      return (
        _Debug_ctorColor(ansi, "Dict") +
        _Debug_fadeColor(ansi, ".fromArray") +
        " " +
        _Debug_toAnsiString(
          ansi,
          A3(
            $gren_lang$core$Dict$foldl,
            F3(function (key, value, acc) {
              acc.push({ key: key, value: value });
              return acc;
            }),
            [],
            value,
          ),
        )
      );
    }

    var output = "";
    for (var i in value) {
      if (i === "$") continue;
      var str = _Debug_toAnsiString(ansi, value[i]);
      var c0 = str[0];
      var parenless =
        c0 === "{" ||
        c0 === "(" ||
        c0 === "[" ||
        c0 === "<" ||
        c0 === '"' ||
        str.indexOf(" ") < 0;
      output += " " + (parenless ? str : "(" + str + ")");
    }
    return _Debug_ctorColor(ansi, tag) + output;
  }

  if (value instanceof DataView) {
    return _Debug_stringColor(ansi, "<" + value.byteLength + " bytes>");
  }

  if (typeof File !== "undefined" && value instanceof File) {
    return _Debug_internalColor(ansi, "<" + value.name + ">");
  }

  if (
    typeof _Array_Builder !== "undefined" &&
    value instanceof _Array_Builder
  ) {
    return _Debug_toAnsiString(ansi, value.array.slice(0, value.target));
  }

  if (typeof value === "object") {
    var output = [];
    for (var key in value) {
      var field = key[0] === "_" ? key.slice(1) : key;
      output.push(
        _Debug_fadeColor(ansi, field) +
          " = " +
          _Debug_toAnsiString(ansi, value[key]),
      );
    }
    if (output.length === 0) {
      return "{}";
    }
    return "{ " + output.join(", ") + " }";
  }

  return _Debug_internalColor(ansi, "<internals>");
}

function _Debug_addSlashes(str, isChar) {
  var s = str
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/\t/g, "\\t")
    .replace(/\r/g, "\\r")
    .replace(/\v/g, "\\v")
    .replace(/\0/g, "\\0");

  if (isChar) {
    return s.replace(/\'/g, "\\'");
  } else {
    return s.replace(/\"/g, '\\"');
  }
}

function _Debug_ctorColor(ansi, string) {
  return ansi ? "\x1b[96m" + string + "\x1b[0m" : string;
}

function _Debug_numberColor(ansi, string) {
  return ansi ? "\x1b[95m" + string + "\x1b[0m" : string;
}

function _Debug_stringColor(ansi, string) {
  return ansi ? "\x1b[93m" + string + "\x1b[0m" : string;
}

function _Debug_charColor(ansi, string) {
  return ansi ? "\x1b[92m" + string + "\x1b[0m" : string;
}

function _Debug_fadeColor(ansi, string) {
  return ansi ? "\x1b[37m" + string + "\x1b[0m" : string;
}

function _Debug_internalColor(ansi, string) {
  return ansi ? "\x1b[36m" + string + "\x1b[0m" : string;
}

function _Debug_toHexDigit(n) {
  return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
}

// CRASH

function _Debug_crash_UNUSED(identifier) {
  throw new Error(
    "https://github.com/gren-lang/core/blob/1.0.0/hints/" + identifier + ".md",
  );
}

function _Debug_crash(identifier, fact1, fact2, fact3, fact4) {
  switch (identifier) {
    case 0:
      throw new Error(
        'What node should I take over? In JavaScript I need something like:\n\n    Gren.Main.init({\n        node: document.getElementById("gren-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.',
      );

    case 1:
      throw new Error(
        "Browser.application programs cannot handle URLs like this:\n\n    " +
          document.location.href +
          "\n\nWhat is the root? The root of your file system?",
      );

    case 2:
      var jsonErrorString = fact1;
      throw new Error(
        "Problem with the flags given to your Gren program on initialization.\n\n" +
          jsonErrorString,
      );

    case 3:
      var portName = fact1;
      throw new Error(
        "There can only be one port named `" +
          portName +
          "`, but your program has multiple.",
      );

    case 4:
      var portName = fact1;
      var problem = fact2;
      throw new Error(
        "Trying to send an unexpected type of value through port `" +
          portName +
          "`:\n" +
          problem,
      );

    case 5:
      throw new Error(
        'Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Gren sense.\nRead more about this at https://package.gren-lang.org/packages/gren-lang/core/latest/Basics#== which describes why it is this way and what the better version will look like.',
      );

    case 6:
      var moduleName = fact1;
      throw new Error(
        "Your page is loading multiple Gren scripts with a module named " +
          moduleName +
          ". Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!",
      );

    case 8:
      var moduleName = fact1;
      var region = fact2;
      var message = fact3;
      throw new Error(
        "TODO in module `" +
          moduleName +
          "` " +
          _Debug_regionToString(region) +
          "\n\n" +
          message,
      );

    case 9:
      var moduleName = fact1;
      var region = fact2;
      var value = fact3;
      var message = fact4;
      throw new Error(
        "TODO in module `" +
          moduleName +
          "` from the `case` expression " +
          _Debug_regionToString(region) +
          "\n\nIt received the following value:\n\n    " +
          _Debug_toString(value).replace("\n", "\n    ") +
          "\n\nBut the branch that handles it says:\n\n    " +
          message.replace("\n", "\n    "),
      );

    case 10:
      throw new Error("Bug in https://github.com/gren-lang/core/issues");

    case 11:
      throw new Error("Cannot perform mod 0. Division by zero error.");
  }
}

function _Debug_regionToString(region) {
  if (region.start.line === region.end.line) {
    return "on line " + region.start.line;
  }
  return (
    "on lines " + region.start.line + " through " + region.end.line
  );
}
var $gren_lang$core$Dict$foldl$ = function(func, acc, dict) {
	foldl:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return acc;
		} else {
			var _v1 = dict.a;
			var key = _v1.key;
			var value = _v1.value;
			var left = _v1.left;
			var right = _v1.right;
			var $temp$func = func,
			$temp$acc = A3(func, key, value, $gren_lang$core$Dict$foldl$(func, acc, left)),
			$temp$dict = right;
			func = $temp$func;
			acc = $temp$acc;
			dict = $temp$dict;
			continue foldl;
		}
	}
};
var $gren_lang$core$Dict$foldl = F3($gren_lang$core$Dict$foldl$);
var $gren_lang$core$Array$length = _Array_length;
var $gren_lang$core$Array$pushLast$ = function(value, array) {
	return A4(_Array_splice1, $gren_lang$core$Array$length(array), 0, value, array);
};
var $gren_lang$core$Array$pushLast = F2($gren_lang$core$Array$pushLast$);
var $gren_lang$core$Dict$keys = function(dict) {
	return $gren_lang$core$Dict$foldl$(F3(function(key, value, keyArray) {
				return $gren_lang$core$Array$pushLast$(key, keyArray);
			}), [  ], dict);
};
var $gren_lang$core$Set$toArray = function(_v0) {
	var dict = _v0.a;
	return $gren_lang$core$Dict$keys(dict);
};
var $gren_lang$core$Basics$EQ = { $: 'EQ' };
var $gren_lang$core$Basics$GT = { $: 'GT' };
var $gren_lang$core$Basics$LT = { $: 'LT' };
var $gren_lang$core$Maybe$Just = function (a) {
	return { $: 'Just', a: a };
};
var $gren_lang$core$Maybe$Nothing = { $: 'Nothing' };
var $gren_lang$core$Basics$apL$ = function(f, x) {
	return f(x);
};
var $gren_lang$core$Basics$apL = F2($gren_lang$core$Basics$apL$);
var $gren_lang$core$Basics$identity = function(x) {
	return x;
};
var $gren_lang$node$Internal$Init$Task = function (a) {
	return { $: 'Task', a: a };
};


// TASKS

function _Scheduler_succeed(value) {
  return {
    $: 0,
    a: value,
  };
}

function _Scheduler_fail(error) {
  return {
    $: 1,
    a: error,
  };
}

function _Scheduler_binding(callback) {
  return {
    $: 2,
    b: callback,
    c: null,
  };
}

var _Scheduler_andThen = F2(function (callback, task) {
  return {
    $: 3,
    b: callback,
    d: task,
  };
});

var _Scheduler_onError = F2(function (callback, task) {
  return {
    $: 4,
    b: callback,
    d: task,
  };
});

function _Scheduler_receive(callback) {
  return {
    $: 5,
    b: callback,
  };
}

// PROCESSES

var _Scheduler_guid = 0;

function _Scheduler_rawSpawn(task) {
  var proc = {
    $: 0,
    e: _Scheduler_guid++,
    f: task,
    g: null,
    h: [],
  };

  _Scheduler_enqueue(proc);

  return proc;
}

function _Scheduler_spawn(task) {
  return _Scheduler_binding(function (callback) {
    callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
  });
}

function _Scheduler_rawSend(proc, msg) {
  proc.h.push(msg);
  _Scheduler_enqueue(proc);
}

var _Scheduler_send = F2(function (proc, msg) {
  return _Scheduler_binding(function (callback) {
    _Scheduler_rawSend(proc, msg);
    callback(_Scheduler_succeed({}));
  });
});

function _Scheduler_kill(proc) {
  return _Scheduler_binding(function (callback) {
    var task = proc.f;
    if (task && task.$ === 2 && task.c) {
      task.c();
    }

    proc.f = null;

    callback(_Scheduler_succeed({}));
  });
}

/* STEP PROCESSES

type alias Process =
  { $ : tag
  , id : unique_id
  , root : Task
  , stack : null | { $: SUCCEED | FAIL, a: callback, b: stack }
  , mailbox : [msg]
  }

*/

var _Scheduler_working = false;
var _Scheduler_queue = [];

function _Scheduler_enqueue(proc) {
  _Scheduler_queue.push(proc);
  if (_Scheduler_working) {
    return;
  }
  _Scheduler_working = true;
  while ((proc = _Scheduler_queue.shift())) {
    _Scheduler_step(proc);
  }
  _Scheduler_working = false;
}

function _Scheduler_step(proc) {
  while (proc.f) {
    var rootTag = proc.f.$;
    if (rootTag === 0 || rootTag === 1) {
      while (proc.g && proc.g.$ !== rootTag) {
        proc.g = proc.g.i;
      }
      if (!proc.g) {
        return;
      }
      proc.f = proc.g.b(proc.f.a);
      proc.g = proc.g.i;
    } else if (rootTag === 2) {
      proc.f.c = proc.f.b(function (newRoot) {
        proc.f = newRoot;
        _Scheduler_enqueue(proc);
      });
      return;
    } else if (rootTag === 5) {
      if (proc.h.length === 0) {
        return;
      }
      proc.f = proc.f.b(proc.h.shift());
    } // if (rootTag === 3 || rootTag === 4)
    else {
      proc.g = {
        $: rootTag === 3 ? 0 : 1,
        b: proc.f.b,
        i: proc.g,
      };
      proc.f = proc.f.d;
    }
  }
}
var $gren_lang$core$Task$andThen = _Scheduler_andThen;
var $gren_lang$core$Basics$composeL$ = function(g, f) {
	return function(x) {
		return g(f(x));
	};
};
var $gren_lang$core$Basics$composeL = F2($gren_lang$core$Basics$composeL$);
var $gren_lang$node$Init$unwrap = function(_v0) {
	var task = _v0.a;
	return task;
};
var $gren_lang$node$Init$await$ = function(_v0, fn) {
	var task = _v0.a;
	return $gren_lang$node$Internal$Init$Task(A2($gren_lang$core$Task$andThen, $gren_lang$core$Basics$composeL$($gren_lang$node$Init$unwrap, fn), task));
};
var $gren_lang$node$Init$await = F2($gren_lang$node$Init$await$);
var $gren_lang$core$Basics$apR$ = function(x, f) {
	return f(x);
};
var $gren_lang$core$Basics$apR = F2($gren_lang$core$Basics$apR$);
var $gren_lang$compiler_node$CLI$Parser$GroupParser = function (a) {
	return { $: 'GroupParser', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$UnknownCommand = function (a) {
	return { $: 'UnknownCommand', a: a };
};
var $gren_lang$core$Dict$RBEmpty_gren_builtin = { $: 'RBEmpty_gren_builtin' };
var $gren_lang$core$Dict$empty = $gren_lang$core$Dict$RBEmpty_gren_builtin;
var $gren_lang$compiler_node$CLI$Parser$defineGroup = $gren_lang$compiler_node$CLI$Parser$GroupParser({ knownCommands: $gren_lang$core$Dict$empty, parseFn: F4(function(_v0, name, _v1, _v2) {
			return $gren_lang$compiler_node$CLI$Parser$UnknownCommand(name);
		}) });
var $gren_lang$compiler_node$CLI$PrettyPrinter$Empty = { $: 'Empty' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$empty = $gren_lang$compiler_node$CLI$PrettyPrinter$Empty;
var $gren_lang$core$Result$Err = function (a) {
	return { $: 'Err', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$FlagParser = function (a) {
	return { $: 'FlagParser', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$FlagParserUnknownFlag = function (a) {
	return { $: 'FlagParserUnknownFlag', a: a };
};
var $gren_lang$core$Result$Ok = function (a) {
	return { $: 'Ok', a: a };
};
var $gren_lang$core$Dict$first = function(dict) {
	first:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return $gren_lang$core$Maybe$Nothing;
		} else {
			if (dict.a.left.$ === 'RBEmpty_gren_builtin') {
				var _v1 = dict.a;
				var key = _v1.key;
				var value = _v1.value;
				var _v2 = _v1.left;
				return $gren_lang$core$Maybe$Just({ key: key, value: value });
			} else {
				var left = dict.a.left;
				var $temp$dict = left;
				dict = $temp$dict;
				continue first;
			}
		}
	}
};
var $gren_lang$compiler_node$CLI$Parser$initFlags = function(value) {
	return $gren_lang$compiler_node$CLI$Parser$FlagParser({ knownFlags: $gren_lang$core$Dict$empty, parseFn: F2(function(knownFlags, remainingFlags) {
				var _v0 = $gren_lang$core$Dict$first(remainingFlags);
				if (_v0.$ === 'Just') {
					var unparsedFlag = _v0.a;
					return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserUnknownFlag({ flagName: unparsedFlag.key, knownFlags: knownFlags }));
				} else {
					return $gren_lang$core$Result$Ok(value);
				}
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$ArgumentParser = function (a) {
	return { $: 'ArgumentParser', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity = function (a) {
	return { $: 'ArgumentParserWrongArity', a: a };
};
var $gren_lang$core$Basics$neq = _Utils_notEqual;
var $gren_lang$compiler_node$CLI$Parser$noArgs = $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: '', parseFn: function(args) {
		return ($gren_lang$core$Array$length(args) !== 0) ? $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity({ actual: $gren_lang$core$Array$length(args), expected: 0 })) : $gren_lang$core$Result$Ok({  });
	} });
var $gren_lang$compiler_node$CLI$Parser$FlagParserInvalidValue = function (a) {
	return { $: 'FlagParserInvalidValue', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$FlagParserMissingValue = function (a) {
	return { $: 'FlagParserMissingValue', a: a };
};
var $gren_lang$core$Basics$compare = _Utils_compare;
var $gren_lang$core$Dict$get$ = function(targetKey, dict) {
	get:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return $gren_lang$core$Maybe$Nothing;
		} else {
			var _v1 = dict.a;
			var key = _v1.key;
			var value = _v1.value;
			var left = _v1.left;
			var right = _v1.right;
			var _v2 = A2($gren_lang$core$Basics$compare, targetKey, key);
			switch (_v2.$) {
				case 'LT':
					var $temp$targetKey = targetKey,
					$temp$dict = left;
					targetKey = $temp$targetKey;
					dict = $temp$dict;
					continue get;
				case 'EQ':
					return $gren_lang$core$Maybe$Just(value);
				default:
					var $temp$targetKey = targetKey,
					$temp$dict = right;
					targetKey = $temp$targetKey;
					dict = $temp$dict;
					continue get;
			}
		}
	}
};
var $gren_lang$core$Dict$get = F2($gren_lang$core$Dict$get$);
var $gren_lang$core$Dict$Black = { $: 'Black' };
var $gren_lang$core$Dict$RBNode_gren_builtin = function (a) {
	return { $: 'RBNode_gren_builtin', a: a };
};
var $gren_lang$core$Dict$node$ = function(color, key, value, left, right) {
	return $gren_lang$core$Dict$RBNode_gren_builtin({ color: color, key: key, left: left, right: right, value: value });
};
var $gren_lang$core$Dict$node = F5($gren_lang$core$Dict$node$);
var $gren_lang$core$Dict$Red = { $: 'Red' };
var $gren_lang$core$Dict$balance$ = function(color, key, value, left, right) {
	if ((right.$ === 'RBNode_gren_builtin') && (right.a.color.$ === 'Red')) {
		var _v1 = right.a;
		var _v2 = _v1.color;
		var rK = _v1.key;
		var rV = _v1.value;
		var rLeft = _v1.left;
		var rRight = _v1.right;
		if ((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Red')) {
			var _v4 = left.a;
			var _v5 = _v4.color;
			var lK = _v4.key;
			var lV = _v4.value;
			var lLeft = _v4.left;
			var lRight = _v4.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, lK, lV, lLeft, lRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, rK, rV, rLeft, rRight));
		} else {
			return $gren_lang$core$Dict$node$(color, rK, rV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, left, rLeft), rRight);
		}
	} else {
		if ((((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Red')) && (left.a.left.$ === 'RBNode_gren_builtin')) && (left.a.left.a.color.$ === 'Red')) {
			var _v7 = left.a;
			var _v8 = _v7.color;
			var lK = _v7.key;
			var lV = _v7.value;
			var _v9 = _v7.left.a;
			var _v10 = _v9.color;
			var llK = _v9.key;
			var llV = _v9.value;
			var llLeft = _v9.left;
			var llRight = _v9.right;
			var lRight = _v7.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, llK, llV, llLeft, llRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, key, value, lRight, right));
		} else {
			return $gren_lang$core$Dict$node$(color, key, value, left, right);
		}
	}
};
var $gren_lang$core$Dict$balance = F5($gren_lang$core$Dict$balance$);
var $gren_lang$core$Basics$eq = _Utils_equal;
var $gren_lang$core$Dict$getMin = function(dict) {
	getMin:
	while (true) {
		if ((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) {
			var left = dict.a.left;
			var $temp$dict = left;
			dict = $temp$dict;
			continue getMin;
		} else {
			return dict;
		}
	}
};
var $gren_lang$core$Basics$lt = _Utils_lt;
var $gren_lang$core$Dict$moveRedLeft = function(dict) {
	if (((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) && (dict.a.right.$ === 'RBNode_gren_builtin')) {
		if ((dict.a.right.a.left.$ === 'RBNode_gren_builtin') && (dict.a.right.a.left.a.color.$ === 'Red')) {
			var _v1 = dict.a;
			var clr = _v1.color;
			var k = _v1.key;
			var v = _v1.value;
			var _v2 = _v1.left.a;
			var lClr = _v2.color;
			var lK = _v2.key;
			var lV = _v2.value;
			var lLeft = _v2.left;
			var lRight = _v2.right;
			var _v3 = _v1.right.a;
			var rClr = _v3.color;
			var rK = _v3.key;
			var rV = _v3.value;
			var rLeft = _v3.left;
			var _v4 = rLeft.a;
			var _v5 = _v4.color;
			var rlK = _v4.key;
			var rlV = _v4.value;
			var rlL = _v4.left;
			var rlR = _v4.right;
			var rRight = _v3.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rlK, rlV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, lLeft, lRight), rlL), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, rK, rV, rlR, rRight));
		} else {
			var _v6 = dict.a;
			var clr = _v6.color;
			var k = _v6.key;
			var v = _v6.value;
			var _v7 = _v6.left.a;
			var lClr = _v7.color;
			var lK = _v7.key;
			var lV = _v7.value;
			var lLeft = _v7.left;
			var lRight = _v7.right;
			var _v8 = _v6.right.a;
			var rClr = _v8.color;
			var rK = _v8.key;
			var rV = _v8.value;
			var rLeft = _v8.left;
			var rRight = _v8.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, lLeft, lRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rK, rV, rLeft, rRight));
		}
	} else {
		return dict;
	}
};
var $gren_lang$core$Dict$moveRedRight = function(dict) {
	if (((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) && (dict.a.right.$ === 'RBNode_gren_builtin')) {
		if ((dict.a.left.a.left.$ === 'RBNode_gren_builtin') && (dict.a.left.a.left.a.color.$ === 'Red')) {
			var _v1 = dict.a;
			var clr = _v1.color;
			var k = _v1.key;
			var v = _v1.value;
			var _v2 = _v1.left.a;
			var lClr = _v2.color;
			var lK = _v2.key;
			var lV = _v2.value;
			var _v3 = _v2.left.a;
			var _v4 = _v3.color;
			var llK = _v3.key;
			var llV = _v3.value;
			var llLeft = _v3.left;
			var llRight = _v3.right;
			var lRight = _v2.right;
			var _v5 = _v1.right.a;
			var rClr = _v5.color;
			var rK = _v5.key;
			var rV = _v5.value;
			var rLeft = _v5.left;
			var rRight = _v5.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, llK, llV, llLeft, llRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, lRight, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rK, rV, rLeft, rRight)));
		} else {
			var _v6 = dict.a;
			var clr = _v6.color;
			var k = _v6.key;
			var v = _v6.value;
			var _v7 = _v6.left.a;
			var lClr = _v7.color;
			var lK = _v7.key;
			var lV = _v7.value;
			var lLeft = _v7.left;
			var lRight = _v7.right;
			var _v8 = _v6.right.a;
			var rClr = _v8.color;
			var rK = _v8.key;
			var rV = _v8.value;
			var rLeft = _v8.left;
			var rRight = _v8.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, lLeft, lRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rK, rV, rLeft, rRight));
		}
	} else {
		return dict;
	}
};
var $gren_lang$core$Dict$removeHelpPrepEQGT$ = function(targetKey, dict, color, key, value, left, right) {
	if ((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Red')) {
		var _v1 = left.a;
		var _v2 = _v1.color;
		var lK = _v1.key;
		var lV = _v1.value;
		var lLeft = _v1.left;
		var lRight = _v1.right;
		return $gren_lang$core$Dict$node$(color, lK, lV, lLeft, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, lRight, right));
	} else {
		_v3$2:
		while (true) {
			if ((right.$ === 'RBNode_gren_builtin') && (right.a.color.$ === 'Black')) {
				if (right.a.left.$ === 'RBNode_gren_builtin') {
					if (right.a.left.a.color.$ === 'Black') {
						var _v4 = right.a;
						var _v5 = _v4.color;
						var _v6 = _v4.left.a.color;
						return $gren_lang$core$Dict$moveRedRight(dict);
					} else {
						break _v3$2;
					}
				} else {
					var _v7 = right.a;
					var _v8 = _v7.color;
					var _v9 = _v7.left;
					return $gren_lang$core$Dict$moveRedRight(dict);
				}
			} else {
				break _v3$2;
			}
		}
		return dict;
	}
};
var $gren_lang$core$Dict$removeHelpPrepEQGT = F7($gren_lang$core$Dict$removeHelpPrepEQGT$);
var $gren_lang$core$Dict$removeMin = function(dict) {
	if ((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) {
		var _v1 = dict.a;
		var color = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var _v2 = left.a;
		var lColor = _v2.color;
		var lLeft = _v2.left;
		var right = _v1.right;
		if (lColor.$ === 'Black') {
			if ((lLeft.$ === 'RBNode_gren_builtin') && (lLeft.a.color.$ === 'Red')) {
				var _v5 = lLeft.a.color;
				return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeMin(left), right);
			} else {
				var _v6 = $gren_lang$core$Dict$moveRedLeft(dict);
				if (_v6.$ === 'RBNode_gren_builtin') {
					var _v7 = _v6.a;
					var nColor = _v7.color;
					var nKey = _v7.key;
					var nValue = _v7.value;
					var nLeft = _v7.left;
					var nRight = _v7.right;
					return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, $gren_lang$core$Dict$removeMin(nLeft), nRight);
				} else {
					return $gren_lang$core$Dict$RBEmpty_gren_builtin;
				}
			}
		} else {
			return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeMin(left), right);
		}
	} else {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	}
};
var $gren_lang$core$Dict$removeHelp$ = function(targetKey, dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	} else {
		var _v5 = dict.a;
		var color = _v5.color;
		var key = _v5.key;
		var value = _v5.value;
		var left = _v5.left;
		var right = _v5.right;
		if (_Utils_cmp(targetKey, key) < 0) {
			if ((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Black')) {
				var _v7 = left.a;
				var _v8 = _v7.color;
				var lLeft = _v7.left;
				if ((lLeft.$ === 'RBNode_gren_builtin') && (lLeft.a.color.$ === 'Red')) {
					var _v10 = lLeft.a.color;
					return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeHelp$(targetKey, left), right);
				} else {
					var _v11 = $gren_lang$core$Dict$moveRedLeft(dict);
					if (_v11.$ === 'RBNode_gren_builtin') {
						var _v12 = _v11.a;
						var nColor = _v12.color;
						var nKey = _v12.key;
						var nValue = _v12.value;
						var nLeft = _v12.left;
						var nRight = _v12.right;
						return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, $gren_lang$core$Dict$removeHelp$(targetKey, nLeft), nRight);
					} else {
						return $gren_lang$core$Dict$RBEmpty_gren_builtin;
					}
				}
			} else {
				return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeHelp$(targetKey, left), right);
			}
		} else {
			return $gren_lang$core$Dict$removeHelpEQGT$(targetKey, $gren_lang$core$Dict$removeHelpPrepEQGT$(targetKey, dict, color, key, value, left, right));
		}
	}
};
var $gren_lang$core$Dict$removeHelp = F2($gren_lang$core$Dict$removeHelp$);
var $gren_lang$core$Dict$removeHelpEQGT$ = function(targetKey, dict) {
	if (dict.$ === 'RBNode_gren_builtin') {
		var _v1 = dict.a;
		var color = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		if (_Utils_eq(targetKey, key)) {
			var _v2 = $gren_lang$core$Dict$getMin(right);
			if (_v2.$ === 'RBNode_gren_builtin') {
				var _v3 = _v2.a;
				var minKey = _v3.key;
				var minValue = _v3.value;
				return $gren_lang$core$Dict$balance$(color, minKey, minValue, left, $gren_lang$core$Dict$removeMin(right));
			} else {
				return $gren_lang$core$Dict$RBEmpty_gren_builtin;
			}
		} else {
			return $gren_lang$core$Dict$balance$(color, key, value, left, $gren_lang$core$Dict$removeHelp$(targetKey, right));
		}
	} else {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	}
};
var $gren_lang$core$Dict$removeHelpEQGT = F2($gren_lang$core$Dict$removeHelpEQGT$);
var $gren_lang$core$Dict$remove$ = function(key, dict) {
	var _v0 = $gren_lang$core$Dict$removeHelp$(key, dict);
	if ((_v0.$ === 'RBNode_gren_builtin') && (_v0.a.color.$ === 'Red')) {
		var _v1 = _v0.a;
		var _v2 = _v1.color;
		var nKey = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, nKey, value, left, right);
	} else {
		var x = _v0;
		return x;
	}
};
var $gren_lang$core$Dict$remove = F2($gren_lang$core$Dict$remove$);
var $gren_lang$core$Dict$setHelp$ = function(key, value, dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, $gren_lang$core$Dict$RBEmpty_gren_builtin, $gren_lang$core$Dict$RBEmpty_gren_builtin);
	} else {
		var _v1 = dict.a;
		var nColor = _v1.color;
		var nKey = _v1.key;
		var nValue = _v1.value;
		var nLeft = _v1.left;
		var nRight = _v1.right;
		var _v2 = A2($gren_lang$core$Basics$compare, key, nKey);
		switch (_v2.$) {
			case 'LT':
				return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, $gren_lang$core$Dict$setHelp$(key, value, nLeft), nRight);
			case 'EQ':
				return $gren_lang$core$Dict$node$(nColor, nKey, value, nLeft, nRight);
			default:
				return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, nLeft, $gren_lang$core$Dict$setHelp$(key, value, nRight));
		}
	}
};
var $gren_lang$core$Dict$setHelp = F3($gren_lang$core$Dict$setHelp$);
var $gren_lang$core$Dict$set$ = function(setKey, setValue, dict) {
	var _v0 = $gren_lang$core$Dict$setHelp$(setKey, setValue, dict);
	if ((_v0.$ === 'RBNode_gren_builtin') && (_v0.a.color.$ === 'Red')) {
		var _v1 = _v0.a;
		var _v2 = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, key, value, left, right);
	} else {
		var x = _v0;
		return x;
	}
};
var $gren_lang$core$Dict$set = F3($gren_lang$core$Dict$set$);
var $gren_lang$compiler_node$CLI$Parser$flag$ = function(key, valueParserFn, desc, _v0) {
	var _v1 = _v0.a;
	var knownFlags = _v1.knownFlags;
	var previousSteps = _v1.parseFn;
	var descriptor = { description: desc, examples: valueParserFn.examples, title: valueParserFn.singular };
	return $gren_lang$compiler_node$CLI$Parser$FlagParser({ knownFlags: $gren_lang$core$Dict$set$(key, descriptor, knownFlags), parseFn: F2(function(flagDescriptions, opts) {
				var _v2 = A2(previousSteps, flagDescriptions, $gren_lang$core$Dict$remove$(key, opts));
				if (_v2.$ === 'Ok') {
					var next = _v2.a;
					var _v3 = $gren_lang$core$Dict$get$(key, opts);
					if (_v3.$ === 'Just') {
						if (_v3.a === '') {
							return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserMissingValue({ flagName: key, knownFlags: flagDescriptions }));
						} else {
							var value = _v3.a;
							var _v4 = valueParserFn.fn(value);
							if (_v4.$ === 'Just') {
								var parsedValue = _v4.a;
								return $gren_lang$core$Result$Ok(next($gren_lang$core$Maybe$Just(parsedValue)));
							} else {
								return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserInvalidValue({ flagName: key, knownFlags: flagDescriptions }));
							}
						}
					} else {
						return $gren_lang$core$Result$Ok(next($gren_lang$core$Maybe$Nothing));
					}
				} else {
					var err = _v2.a;
					return $gren_lang$core$Result$Err(err);
				}
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$flag = F4($gren_lang$compiler_node$CLI$Parser$flag$);
var $author$project$Main$simpleFlag = function(string) {
	return A3($gren_lang$compiler_node$CLI$Parser$flag, string, { examples: [  ], fn: function(val) {
			return $gren_lang$core$Maybe$Just(val);
		}, plural: string, singular: string }, string);
};
var $gren_lang$compiler_node$CLI$Parser$BadArguments = function (a) {
	return { $: 'BadArguments', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$BadFlags = function (a) {
	return { $: 'BadFlags', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$HelpText = function (a) {
	return { $: 'HelpText', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$Success = function (a) {
	return { $: 'Success', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Cyan = { $: 'Cyan' };
var $gren_lang$core$Basics$append = _Utils_append;
var $gren_lang$compiler_node$CLI$PrettyPrinter$Colorized = function (a) {
	return { $: 'Colorized', a: a };
};
var $gren_lang$core$Basics$False = { $: 'False' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$color$ = function(clr, doc) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Colorized({ color: clr, document: doc, intense: false });
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$color = F2($gren_lang$compiler_node$CLI$PrettyPrinter$color$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$Indented = function (a) {
	return { $: 'Indented', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$indent = function(doc) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Indented(doc);
};
var $gren_lang$core$Array$prepend = _Array_append;
var $gren_lang$compiler_node$CLI$PrettyPrinter$Text = function (a) {
	return { $: 'Text', a: a };
};


var _String_pushFirst = F2(function (char, string) {
  return char + string;
});

var _String_pushLast = F2(function (char, string) {
  return string + char;
});

var _String_popFirst = function (string) {
  if (string.length <= 0) {
    return $gren_lang$core$Maybe$Nothing;
  }

  var firstPointNumber = string.codePointAt(0);
  var firstChar = String.fromCodePoint(firstPointNumber);

  return $gren_lang$core$Maybe$Just({
    first: _Utils_chr(firstChar),
    rest: string.slice(firstChar.length),
  });
};

var _String_popLast = function (string) {
  if (string.length <= 0) {
    return $gren_lang$core$Maybe$Nothing;
  }

  var possibleLastPointIdx = string.length - 2;
  var possibleLastPoint = string.codePointAt(possibleLastPointIdx);

  if (possibleLastPoint === string.charCodeAt(possibleLastPointIdx)) {
    // last char is a unit
    return $gren_lang$core$Maybe$Just({
      last: _Utils_chr(string[string.length - 1]),
      rest: string.slice(string.length - 1),
    });
  }

  // last char is a point
  return $gren_lang$core$Maybe$Just({
    last: _Utils_chr(String.fromCodePoint(possibleLastPoint)),
    rest: string.slice(string.length - 2),
  });
};

var _String_append = F2(function (a, b) {
  return a + b;
});

var _String_repeat = F2(function (num, chunk) {
  try {
    return chunk.repeat(num);
  } catch (error) {
    if (error.name === "RangeError") {
      return "";
    } else {
      throw error;
    }
  }
});

var _String_foldl = F3(function (func, state, string) {
  for (let char of string) {
    state = A2(func, _Utils_chr(char), state);
  }

  return state;
});

var _String_foldr = F3(function (func, state, string) {
  let reversed = [];

  for (let char of string) {
    reversed.unshift(char);
  }

  for (let char of reversed) {
    state = A2(func, _Utils_chr(char), state);
  }

  return state;
});

var _String_split = F2(function (sep, str) {
  return str.split(sep);
});

var _String_join = F2(function (sep, strs) {
  return strs.join(sep);
});

var _String_slice = F3(function (start, end, str) {
  if (start < 0) {
    start = str.length + start;
  }

  if (end < 0) {
    end = str.length + end;
  }

  if (start >= end) {
    return "";
  }

  let index = 0;
  let result = "";

  for (let char of str) {
    if (index < start) {
      index++;
      continue;
    }

    if (index >= end) {
      break;
    }

    result += char;
    index++;
  }

  return result;
});

function _String_trim(str) {
  return str.trim();
}

function _String_trimLeft(str) {
  return str.replace(/^\s+/, "");
}

function _String_trimRight(str) {
  return str.replace(/\s+$/, "");
}

function _String_words(str) {
  return str.trim().split(/\s+/g);
}

function _String_lines(str) {
  return str.split(/\r\n|\r|\n/g);
}

function _String_toUpper(str) {
  return str.toUpperCase();
}

function _String_toLower(str) {
  return str.toLowerCase();
}

var _String_any = F2(function (isGood, string) {
  for (let char of string) {
    if (isGood(_Utils_chr(char))) {
      return true;
    }
  }

  return false;
});

var _String_contains = F2(function (sub, str) {
  return str.indexOf(sub) > -1;
});

var _String_startsWith = F2(function (sub, str) {
  return str.indexOf(sub) === 0;
});

var _String_endsWith = F2(function (sub, str) {
  return (
    str.length >= sub.length && str.lastIndexOf(sub) === str.length - sub.length
  );
});

var _String_indexOf = F2(function (sub, str) {
  var ret = str.indexOf(sub);

  if (ret > -1) {
    return $gren_lang$core$Maybe$Just(ret);
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _String_lastIndexOf = F2(function (sub, str) {
  var ret = str.lastIndexOf(sub);

  if (ret > -1) {
    return $gren_lang$core$Maybe$Just(ret);
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _String_indexes = F2(function (sub, str) {
  var subLen = sub.length;

  if (subLen < 1) {
    return [];
  }

  var i = 0;
  var is = [];

  while ((i = str.indexOf(sub, i)) > -1) {
    is.push(i);
    i = i + subLen;
  }

  return is;
});

// TO STRING

function _String_fromNumber(number) {
  return number + "";
}

// INT CONVERSIONS

function _String_toInt(str) {
  var total = 0;
  var code0 = str.charCodeAt(0);
  var start = code0 == 0x2b /* + */ || code0 == 0x2d /* - */ ? 1 : 0;

  for (var i = start; i < str.length; ++i) {
    var code = str.charCodeAt(i);
    if (code < 0x30 || 0x39 < code) {
      return $gren_lang$core$Maybe$Nothing;
    }
    total = 10 * total + code - 0x30;
  }

  return i == start
    ? $gren_lang$core$Maybe$Nothing
    : $gren_lang$core$Maybe$Just(code0 == 0x2d ? -total : total);
}

// FLOAT CONVERSIONS

function _String_toFloat(s) {
  // check if it is a hex, octal, or binary number
  if (s.length === 0 || /[\sxbo]/.test(s)) {
    return $gren_lang$core$Maybe$Nothing;
  }
  var n = +s;
  // faster isNaN check
  return n === n ? $gren_lang$core$Maybe$Just(n) : $gren_lang$core$Maybe$Nothing;
}

function _String_fromArray(chars) {
  return chars.join("");
}

// UNITS

var _String_unitLength = function (str) {
  return str.length;
};

var _String_getUnit = F2(function (index, str) {
  var ret = str.at(index);

  if (typeof ret === "undefined") {
    return $gren_lang$core$Maybe$Nothing;
  }

  return $gren_lang$core$Maybe$Just(_Utils_chr(char));
});

var _String_foldlUnits = F3(function (fn, state, str) {
  for (let i = 0; i < str.length; i++) {
    state = A2(fn, str[i], state);
  }

  return state;
});

var _String_foldrUnits = F3(function (fn, state, str) {
  for (let i = str.length - 1; i < 0; i--) {
    state = A2(fn, str[i], state);
  }

  return state;
});
var $gren_lang$core$String$join = _String_join;
var $gren_lang$core$String$split = _String_split;
var $gren_lang$core$String$replace$ = function(before, after, string) {
	return A2($gren_lang$core$String$join, after, A2($gren_lang$core$String$split, before, string));
};
var $gren_lang$core$String$replace = F3($gren_lang$core$String$replace$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$text = function(str) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Text($gren_lang$core$String$replace$('\n', ' ', $gren_lang$core$String$replace$('\r', '', str)));
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$VerticalBlock = function (a) {
	return { $: 'VerticalBlock', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock = function(docs) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$VerticalBlock(docs);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Words = function (a) {
	return { $: 'Words', a: a };
};
var $gren_lang$core$String$words = _String_words;
var $gren_lang$compiler_node$CLI$PrettyPrinter$words = function(str) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Words($gren_lang$core$String$words(str));
};
var $gren_lang$compiler_node$CLI$Parser$commandHelpText$ = function(appName, spec) {
	var _v0 = spec.flags;
	var knownFlags = _v0.a.knownFlags;
	var flagDocument = $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock($gren_lang$core$Dict$foldl$(F3(function(flagName, flagDescription, acc) {
						var flagSuffix = (flagDescription.title === '') ? '' : ('=<' + (flagDescription.title + '>'));
						return A2($gren_lang$core$Array$prepend, acc, [ $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + (flagName + flagSuffix))), $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words(flagDescription.description)), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
					}), [  ], knownFlags)));
	var _v1 = spec._arguments;
	var argumentType = _v1.a.description;
	return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words(spec.summary), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words(appName + (' ' + (spec.word + (' ' + argumentType)))))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, spec.example, $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('You can customize this command with the following flags:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, flagDocument ]);
};
var $gren_lang$compiler_node$CLI$Parser$commandHelpText = F2($gren_lang$compiler_node$CLI$Parser$commandHelpText$);
var $gren_lang$compiler_node$CLI$Parser$runCommand$ = function(appName, args, flags, spec) {
	var _v0 = spec.flags;
	var _v1 = _v0.a;
	var knownFlags = _v1.knownFlags;
	var parseFlags = _v1.parseFn;
	var _v2 = spec._arguments;
	var parseArgs = _v2.a.parseFn;
	var _v3 = $gren_lang$core$Dict$get$('help', flags);
	if ((_v3.$ === 'Just') && (_v3.a === '')) {
		return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$Parser$commandHelpText$(appName, spec));
	} else {
		var _v4 = { argResult: parseArgs(args), flagResult: A2(parseFlags, knownFlags, flags) };
		if (_v4.argResult.$ === 'Ok') {
			if (_v4.flagResult.$ === 'Ok') {
				var argValue = _v4.argResult.a;
				var flagValues = _v4.flagResult.a;
				return $gren_lang$compiler_node$CLI$Parser$Success(A2(spec.builder, argValue, flagValues));
			} else {
				var err = _v4.flagResult.a;
				return $gren_lang$compiler_node$CLI$Parser$BadFlags(err);
			}
		} else {
			var err = _v4.argResult.a;
			return $gren_lang$compiler_node$CLI$Parser$BadArguments(err);
		}
	}
};
var $gren_lang$compiler_node$CLI$Parser$runCommand = F4($gren_lang$compiler_node$CLI$Parser$runCommand$);
var $gren_lang$compiler_node$CLI$Parser$withCommand$ = function(command, _v0) {
	var _v1 = _v0.a;
	var knownCommands = _v1.knownCommands;
	var next = _v1.parseFn;
	return $gren_lang$compiler_node$CLI$Parser$GroupParser({ knownCommands: $gren_lang$core$Dict$set$(command.word, command.commonDescription, knownCommands), parseFn: F4(function(appName, name, args, flags) {
				return (!_Utils_eq(name, command.word)) ? A4(next, appName, name, args, flags) : $gren_lang$compiler_node$CLI$Parser$runCommand$(appName, args, flags, command);
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$withCommand = F2($gren_lang$compiler_node$CLI$Parser$withCommand$);
var $author$project$Main$cliConfig = { commands: $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v0, flags) {
			return flags;
		}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$empty, flags: A2($author$project$Main$simpleFlag, 'org', A2($author$project$Main$simpleFlag, 'group', A2($author$project$Main$simpleFlag, 'token', $gren_lang$compiler_node$CLI$Parser$initFlags(F3(function(token_, group, org) {
							return { group: group, org: org, token: token_ };
						}))))), summary: '', word: 'test' }, $gren_lang$compiler_node$CLI$Parser$defineGroup), intro: $gren_lang$compiler_node$CLI$PrettyPrinter$empty, name: 'gren-turso-tests', outro: $gren_lang$compiler_node$CLI$PrettyPrinter$empty, version: '1.0.0' };
var $gren_lang$node$Node$InitDone = function (a) {
	return { $: 'InitDone', a: a };
};
var $gren_lang$node$Node$Uninitialized = { $: 'Uninitialized' };


var stream = require("node:stream");
var process = require("node:process");

var _Node_log = F2(function (text, args) {
  // This function is used for simple applications where the main function returns String
  // NOTE: this function needs _Platform_export available to work
  console.log(text);
  return {};
});

var _Node_init = _Scheduler_binding(function (callback) {
  if (process.stdin.unref) {
    // Don't block program shutdown if this is the only
    // stream being listened to
    process.stdin.unref();
  }

  const stdinStream = stream.Readable.toWeb(process.stdin);
  const stdinProxy = !process.stdin.ref
    ? stdinStream
    : _Node_makeProxyOfStdin(stdinStream);

  callback(
    _Scheduler_succeed({
      applicationPath: _FilePath_fromString(
        typeof module !== "undefined" ? module.filename : process.execPath,
      ),
      arch: process.arch,
      args: process.argv,
      platform: process.platform,
      stderr: stream.Writable.toWeb(process.stderr),
      stdin: stdinProxy,
      stdout: stream.Writable.toWeb(process.stdout),
    }),
  );
});

function _Node_makeProxyOfStdin(stdinStream) {
  return new Proxy(stdinStream, {
    get(target, prop, receiver) {
      if (prop === "getReader") {
        // Make sure to keep program alive if we're waiting for
        // user input
        process.stdin.ref();

        const reader = Reflect.get(target, prop, receiver);
        return _Node_makeProxyOfReader(reader);
      }

      if (prop === "pipeThrough") {
        process.stdin.ref();
      }

      return Reflect.get(target, prop, receiver);
    },
  });
}

function _Node_makeProxyOfReader(reader) {
  return new Proxy(reader, {
    get(target, prop, receiver) {
      if (prop === "releaseLock") {
        process.stdin.unref();
      }

      return Reflect.get(target, prop, receiver);
    },
  });
}

var _Node_getPlatform = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(process.platform));
});

var _Node_getCpuArchitecture = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(process.arch));
});

var _Node_getEnvironmentVariables = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(_Node_objToDict(process.env)));
});

var _Node_exitWithCode = function (code) {
  return _Scheduler_binding(function (callback) {
    process.exit(code);
  });
};

var _Node_setExitCode = function (code) {
  return _Scheduler_binding(function (callback) {
    process.exitCode = code;
    callback(_Scheduler_succeed({}));
  });
};

// Helpers

function _Node_objToDict(obj) {
  var dict = $gren_lang$core$Dict$empty;

  for (var key in obj) {
    dict = A3($gren_lang$core$Dict$set, key, obj[key], dict);
  }

  return dict;
}


var path = require("node:path");
var process = require("node:process");

var _FilePath_fromPosix = function (str) {
  return _FilePath_parse(path.posix, str);
};

var _FilePath_fromWin32 = function (str) {
  return _FilePath_parse(path.win32, str);
};

var _FilePath_fromString = function (str) {
  return _FilePath_parse(path, str);
};

var _FilePath_parse = function (pathMod, str) {
  const result = pathMod.parse(pathMod.normalize(str));

  const root = result.root;

  let dirStr = result.dir.startsWith(root)
    ? result.dir.substring(root.length)
    : result.dir;

  if (str.startsWith(`.${path.sep}`)) {
    dirStr = `.${path.sep}` + dirStr;
  }

  const filename =
    result.name === "." && result.ext.length === 0 ? "" : result.name;

  return {
    directory:
      dirStr === ""
        ? []
        : dirStr.split(pathMod.sep).filter((dir) => dir.length > 0),
    extension: result.ext.length > 0 ? result.ext.substring(1) : "",
    filename: filename,
    root: result.root,
  };
};

var _FilePath_toPosix = function (filePath) {
  if (_FilePath_isEmpty(filePath)) {
    return ".";
  }

  if (filePath.root !== "" && filePath.root !== "/") {
    filePath = { ...filePath, root: "/" };
  }

  return _FilePath_format(path.posix, filePath);
};

var _FilePath_toWin32 = function (filePath) {
  if (_FilePath_isEmpty(filePath)) {
    return ".";
  }

  return _FilePath_format(path.win32, filePath);
};

var _FilePath_toString = function (filePath) {
  if (process.platform.toLowerCase() === "win32") {
    return _FilePath_toWin32(filePath);
  }

  return _FilePath_toPosix(filePath);
};

var _FilePath_isEmpty = function (filePath) {
  return (
    filePath.root === "" &&
    filePath.directory.length === 0 &&
    filePath.filename === "" &&
    filePath.extension === ""
  );
};

var _FilePath_format = function (pathMod, filePath) {
  const filename =
    filePath.extension.length > 0
      ? filePath.filename + "." + filePath.extension
      : filePath.filename;

  let pathArray = null;
  if (filename === "") {
    pathArray = filePath.directory;
  } else {
    pathArray = filePath.directory.concat(filename);
  }

  return filePath.root + pathArray.join(pathMod.sep);
};


// PROGRAMS

var _Platform_worker = F3(function (impl, flagDecoder, args) {
  return _Platform_initialize(
    flagDecoder,
    args,
    impl.init,
    impl.update,
    impl.subscriptions,
    function () {
      return function () {};
    },
  );
});

// INITIALIZE A PROGRAM

function _Platform_initialize(
  flagDecoder,
  args,
  init,
  update,
  subscriptions,
  stepperBuilder,
) {
  var result = A2(
    _Json_run,
    flagDecoder,
    _Json_wrap(args ? args["flags"] : undefined),
  );
  $gren_lang$core$Result$isOk(result) ||
    _Debug_crash(2 /**/, _Json_errorToString(result.a) /**/);
  var managers = {};
  var initPair = init(result.a);
  var model = initPair.model;
  var stepper = stepperBuilder(sendToApp, model);
  var ports = _Platform_setupEffects(managers, sendToApp);

  function sendToApp(msg, viewMetadata) {
    var pair = A2(update, msg, model);
    stepper((model = pair.model), viewMetadata);
    _Platform_enqueueEffects(managers, pair.command, subscriptions(model));
  }

  _Platform_enqueueEffects(managers, initPair.command, subscriptions(model));

  return ports ? { ports: ports } : {};
}

// TRACK PRELOADS
//
// This is used by code in gren/browser and gren/http
// to register any HTTP requests that are triggered by init.
//

var _Platform_preload;

function _Platform_registerPreload(url) {
  _Platform_preload.add(url);
}

// EFFECT MANAGERS

var _Platform_effectManagers = {};

function _Platform_setupEffects(managers, sendToApp) {
  var ports;

  // setup all necessary effect managers
  for (var key in _Platform_effectManagers) {
    var manager = _Platform_effectManagers[key];

    if (manager.a) {
      ports = ports || {};
      ports[key] = manager.a(key, sendToApp);
    }

    managers[key] = _Platform_instantiateManager(manager, sendToApp);
  }

  return ports;
}

function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap) {
  return {
    b: init,
    c: onEffects,
    d: onSelfMsg,
    e: cmdMap,
    f: subMap,
  };
}

function _Platform_instantiateManager(info, sendToApp) {
  var router = {
    g: sendToApp,
    h: undefined,
  };

  var onEffects = info.c;
  var onSelfMsg = info.d;
  var cmdMap = info.e;
  var subMap = info.f;

  function loop(state) {
    return A2(
      _Scheduler_andThen,
      loop,
      _Scheduler_receive(function (msg) {
        var value = msg.a;

        if (msg.$ === 0) {
          return A3(onSelfMsg, router, value, state);
        }

        return cmdMap && subMap
          ? A4(onEffects, router, value.i, value.j, state)
          : A3(onEffects, router, cmdMap ? value.i : value.j, state);
      }),
    );
  }

  return (router.h = _Scheduler_rawSpawn(
    A2(_Scheduler_andThen, loop, info.b),
  ));
}

// ROUTING

var _Platform_sendToApp = F2(function (router, msg) {
  return _Scheduler_binding(function (callback) {
    router.g(msg);
    callback(_Scheduler_succeed({}));
  });
});

var _Platform_sendToSelf = F2(function (router, msg) {
  return A2(_Scheduler_send, router.h, {
    $: 0,
    a: msg,
  });
});

// BAGS

function _Platform_leaf(home) {
  return function (value) {
    return {
      $: 1,
      k: home,
      l: value,
    };
  };
}

function _Platform_batch(array) {
  return {
    $: 2,
    m: array,
  };
}

var _Platform_map = F2(function (tagger, bag) {
  return {
    $: 3,
    n: tagger,
    o: bag,
  };
});

// PIPE BAGS INTO EFFECT MANAGERS
//
// Effects must be queued!
//
// Say your init contains a synchronous command, like Time.now or Time.here
//
//   - This will produce a batch of effects (FX_1)
//   - The synchronous task triggers the subsequent `update` call
//   - This will produce a batch of effects (FX_2)
//
// If we just start dispatching FX_2, subscriptions from FX_2 can be processed
// before subscriptions from FX_1. No good! Earlier versions of this code had
// this problem, leading to these reports:
//
//   https://github.com/gren/core/issues/980
//   https://github.com/gren/core/pull/981
//   https://github.com/gren/compiler/issues/1776
//
// The queue is necessary to avoid ordering issues for synchronous commands.

// Why use true/false here? Why not just check the length of the queue?
// The goal is to detect "are we currently dispatching effects?" If we
// are, we need to bail and let the ongoing while loop handle things.
//
// Now say the queue has 1 element. When we dequeue the final element,
// the queue will be empty, but we are still actively dispatching effects.
// So you could get queue jumping in a really tricky category of cases.
//
var _Platform_effectsQueue = [];
var _Platform_effectsActive = false;

function _Platform_enqueueEffects(managers, cmdBag, subBag) {
  _Platform_effectsQueue.push({
    p: managers,
    q: cmdBag,
    r: subBag,
  });

  if (_Platform_effectsActive) return;

  _Platform_effectsActive = true;
  for (var fx; (fx = _Platform_effectsQueue.shift()); ) {
    _Platform_dispatchEffects(fx.p, fx.q, fx.r);
  }
  _Platform_effectsActive = false;
}

function _Platform_dispatchEffects(managers, cmdBag, subBag) {
  var effectsDict = {};
  _Platform_gatherEffects(true, cmdBag, effectsDict, null);
  _Platform_gatherEffects(false, subBag, effectsDict, null);

  for (var home in managers) {
    _Scheduler_rawSend(managers[home], {
      $: "fx",
      a: effectsDict[home] || { i: [], j: [] },
    });
  }
}

function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers) {
  switch (bag.$) {
    case 1:
      var home = bag.k;
      var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
      effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
      return;

    case 2:
      var bags = bag.m;
      for (var idx = 0; idx < bags.length; idx++) {
        _Platform_gatherEffects(isCmd, bags[idx], effectsDict, taggers);
      }
      return;

    case 3:
      _Platform_gatherEffects(isCmd, bag.o, effectsDict, {
        s: bag.n,
        t: taggers,
      });
      return;
  }
}

function _Platform_toEffect(isCmd, home, taggers, value) {
  function applyTaggers(x) {
    for (var temp = taggers; temp; temp = temp.t) {
      x = temp.s(x);
    }
    return x;
  }

  var map = isCmd
    ? _Platform_effectManagers[home].e
    : _Platform_effectManagers[home].f;

  return A2(map, applyTaggers, value);
}

function _Platform_insert(isCmd, newEffect, effects) {
  effects = effects || { i: [], j: [] };

  isCmd
    ? (effects.i = A2($gren_lang$core$Array$pushLast, newEffect, effects.i))
    : (effects.j = A2($gren_lang$core$Array$pushLast, newEffect, effects.j));

  return effects;
}

// PORTS

function _Platform_checkPortName(name) {
  if (_Platform_effectManagers[name]) {
    _Debug_crash(3, name);
  }
}

// OUTGOING PORTS

function _Platform_outgoingPort(name, converter) {
  _Platform_checkPortName(name);
  _Platform_effectManagers[name] = {
    e: _Platform_outgoingPortMap,
    u: converter,
    a: _Platform_setupOutgoingPort,
  };
  return _Platform_leaf(name);
}

var _Platform_outgoingPortMap = F2(function (tagger, value) {
  return value;
});

function _Platform_setupOutgoingPort(name) {
  var subs = [];
  var converter = _Platform_effectManagers[name].u;

  // CREATE MANAGER

  var init = _Process_sleep(0);

  _Platform_effectManagers[name].b = init;
  _Platform_effectManagers[name].c = F3(
    function (router, cmdArray, state) {
      for (var idx = 0; idx < cmdArray.length; idx++) {
        // grab a separate reference to subs in case unsubscribe is called
        var currentSubs = subs;
        var value = _Json_unwrap(converter(cmdArray[idx]));
        for (var subIdx = 0; subIdx < currentSubs.length; subIdx++) {
          currentSubs[subIdx](value);
        }
      }
      return init;
    },
  );

  // PUBLIC API

  function subscribe(callback) {
    subs.push(callback);
  }

  function unsubscribe(callback) {
    // copy subs into a new array in case unsubscribe is called within a
    // subscribed callback
    subs = subs.slice();
    var index = subs.indexOf(callback);
    if (index >= 0) {
      subs.splice(index, 1);
    }
  }

  return {
    subscribe: subscribe,
    unsubscribe: unsubscribe,
  };
}

// INCOMING PORTS

function _Platform_incomingPort(name, converter) {
  _Platform_checkPortName(name);
  _Platform_effectManagers[name] = {
    f: _Platform_incomingPortMap,
    u: converter,
    a: _Platform_setupIncomingPort,
  };
  return _Platform_leaf(name);
}

var _Platform_incomingPortMap = F2(function (tagger, finalTagger) {
  return function (value) {
    return tagger(finalTagger(value));
  };
});

function _Platform_setupIncomingPort(name, sendToApp) {
  var subs = [];
  var converter = _Platform_effectManagers[name].u;

  // CREATE MANAGER

  var init = _Scheduler_succeed(null);

  _Platform_effectManagers[name].b = init;
  _Platform_effectManagers[name].c = F3(
    function (router, subArray, state) {
      subs = subArray;
      return init;
    },
  );

  // PUBLIC API

  function send(incomingValue) {
    var result = A2(_Json_run, converter, _Json_wrap(incomingValue));

    $gren_lang$core$Result$isOk(result) || _Debug_crash(4, name, result.a);

    var value = result.a;
    for (var idx = 0; idx < subs.length; idx++) {
      sendToApp(subs[idx](value));
    }
  }

  return { send: send };
}

// EXPORT GREN MODULES
//
// Have DEBUG and PROD versions so that we can (1) give nicer errors in
// debug mode and (2) not pay for the bits needed for that in prod mode.
//

function _Platform_export_UNUSED(exports) {
  scope["Gren"]
    ? _Platform_mergeExportsProd(scope["Gren"], exports)
    : (scope["Gren"] = exports);
}

function _Platform_mergeExportsProd(obj, exports) {
  for (var name in exports) {
    name in obj
      ? name == "init"
        ? _Debug_crash(6)
        : _Platform_mergeExportsProd(obj[name], exports[name])
      : (obj[name] = exports[name]);
  }
}

function _Platform_export(exports) {
  scope["Gren"]
    ? _Platform_mergeExportsDebug("Gren", scope["Gren"], exports)
    : (scope["Gren"] = exports);
}

function _Platform_mergeExportsDebug(moduleName, obj, exports) {
  for (var name in exports) {
    name in obj
      ? name == "init"
        ? _Debug_crash(6, moduleName)
        : _Platform_mergeExportsDebug(
            moduleName + "." + name,
            obj[name],
            exports[name],
          )
      : (obj[name] = exports[name]);
  }
}


/**/
function _Json_errorToString(error)
{
	return $gren_lang$core$Json$Decode$errorToString(error);
}
//*/

// CORE DECODERS

function _Json_succeed(msg) {
  return {
    $: 0,
    a: msg,
  };
}

function _Json_fail(msg) {
  return {
    $: 1,
    a: msg,
  };
}

function _Json_decodePrim(decoder) {
  return { $: 2, b: decoder };
}

var _Json_decodeInt = _Json_decodePrim(function (value) {
  return typeof value !== "number"
    ? _Json_expecting("an INT", value)
    : Math.trunc(value) === value
      ? $gren_lang$core$Result$Ok(value)
      : isFinite(value) && !(value % 1)
        ? $gren_lang$core$Result$Ok(value)
        : _Json_expecting("an INT", value);
});

var _Json_decodeBool = _Json_decodePrim(function (value) {
  return typeof value === "boolean"
    ? $gren_lang$core$Result$Ok(value)
    : _Json_expecting("a BOOL", value);
});

var _Json_decodeFloat = _Json_decodePrim(function (value) {
  return typeof value === "number"
    ? $gren_lang$core$Result$Ok(value)
    : _Json_expecting("a FLOAT", value);
});

var _Json_decodeValue = _Json_decodePrim(function (value) {
  return $gren_lang$core$Result$Ok(_Json_wrap(value));
});

var _Json_decodeString = _Json_decodePrim(function (value) {
  return typeof value === "string"
    ? $gren_lang$core$Result$Ok(value)
    : value instanceof String
      ? $gren_lang$core$Result$Ok(value + "")
      : _Json_expecting("a STRING", value);
});

function _Json_decodeArray(decoder) {
  return { $: 3, b: decoder };
}

function _Json_decodeNull(value) {
  return { $: 4, c: value };
}

var _Json_decodeField = F2(function (field, decoder) {
  return {
    $: 5,
    d: field,
    b: decoder,
  };
});

var _Json_decodeIndex = F2(function (index, decoder) {
  return {
    $: 6,
    e: index,
    b: decoder,
  };
});

function _Json_decodeKeyValuePairs(decoder) {
  return {
    $: 7,
    b: decoder,
  };
}

function _Json_mapMany(f, decoders) {
  return {
    $: 8,
    f: f,
    g: decoders,
  };
}

var _Json_andThen = F2(function (callback, decoder) {
  return {
    $: 9,
    b: decoder,
    h: callback,
  };
});

function _Json_oneOf(decoders) {
  return {
    $: 10,
    g: decoders,
  };
}

// DECODING OBJECTS

var _Json_map1 = F2(function (f, d1) {
  return _Json_mapMany(f, [d1]);
});

var _Json_map2 = F3(function (f, d1, d2) {
  return _Json_mapMany(f, [d1, d2]);
});

var _Json_map3 = F4(function (f, d1, d2, d3) {
  return _Json_mapMany(f, [d1, d2, d3]);
});

var _Json_map4 = F5(function (f, d1, d2, d3, d4) {
  return _Json_mapMany(f, [d1, d2, d3, d4]);
});

var _Json_map5 = F6(function (f, d1, d2, d3, d4, d5) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
});

var _Json_map6 = F7(function (f, d1, d2, d3, d4, d5, d6) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
});

var _Json_map7 = F8(function (f, d1, d2, d3, d4, d5, d6, d7) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
});

var _Json_map8 = F9(function (f, d1, d2, d3, d4, d5, d6, d7, d8) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
});

// DECODE

var _Json_runOnString = F2(function (decoder, string) {
  try {
    var value = JSON.parse(string);
    return _Json_runHelp(decoder, value);
  } catch (e) {
    return $gren_lang$core$Result$Err(
      $gren_lang$core$Json$Decode$Failure({
        message: "This is not valid JSON! " + e.message,
        value: _Json_wrap(string),
      }),
    );
  }
});

var _Json_run = F2(function (decoder, value) {
  return _Json_runHelp(decoder, _Json_unwrap(value));
});

function _Json_runHelp(decoder, value) {
  switch (decoder.$) {
    case 2:
      return decoder.b(value);

    case 4:
      return value === null
        ? $gren_lang$core$Result$Ok(decoder.c)
        : _Json_expecting("null", value);

    case 3:
      if (!_Json_isArray(value)) {
        return _Json_expecting("an ARRAY", value);
      }
      return _Json_runArrayDecoder(decoder.b, value);

    case 5:
      var field = decoder.d;
      if (typeof value !== "object" || value === null || !(field in value)) {
        return _Json_expecting(
          "an OBJECT with a field named `" + field + "`",
          value,
        );
      }
      var result = _Json_runHelp(decoder.b, value[field]);
      return $gren_lang$core$Result$isOk(result)
        ? result
        : $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$Field({ name: field, error: result.a }));

    case 6:
      var index = decoder.e;
      if (!_Json_isArray(value)) {
        return _Json_expecting("an ARRAY", value);
      }
      if (index >= value.length) {
        return _Json_expecting(
          "a LONGER array. Need index " +
            index +
            " but only see " +
            value.length +
            " entries",
          value,
        );
      }
      var result = _Json_runHelp(decoder.b, value[index]);
      return $gren_lang$core$Result$isOk(result)
        ? result
        : $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$Index({ index: index, error: result.a }));

    case 7:
      if (typeof value !== "object" || value === null || _Json_isArray(value)) {
        return _Json_expecting("an OBJECT", value);
      }

      var keyValuePairs = [];
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var result = _Json_runHelp(decoder.b, value[key]);
          if (!$gren_lang$core$Result$isOk(result)) {
            return $gren_lang$core$Result$Err(
              $gren_lang$core$Json$Decode$Field({ name: key, error: result.a }),
            );
          }
          keyValuePairs.push({ key: key, value: result.a });
        }
      }
      return $gren_lang$core$Result$Ok(keyValuePairs);

    case 8:
      var answer = decoder.f;
      var decoders = decoder.g;
      for (var i = 0; i < decoders.length; i++) {
        var result = _Json_runHelp(decoders[i], value);
        if (!$gren_lang$core$Result$isOk(result)) {
          return result;
        }
        answer = answer(result.a);
      }
      return $gren_lang$core$Result$Ok(answer);

    case 9:
      var result = _Json_runHelp(decoder.b, value);
      return !$gren_lang$core$Result$isOk(result)
        ? result
        : _Json_runHelp(decoder.h(result.a), value);

    case 10:
      var errors = [];

      var decoders = decoder.g;
      for (var idx = 0; idx < decoders.length; idx++) {
        var result = _Json_runHelp(decoders[idx], value);
        if ($gren_lang$core$Result$isOk(result)) {
          return result;
        }
        errors.push(result.a);
      }

      return $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$OneOf(errors));

    case 1:
      return $gren_lang$core$Result$Err(
        $gren_lang$core$Json$Decode$Failure({
          message: decoder.a,
          value: _Json_wrap(value),
        }),
      );

    case 0:
      return $gren_lang$core$Result$Ok(decoder.a);
  }
}

function _Json_runArrayDecoder(decoder, value) {
  var len = value.length;
  var array = new Array(len);
  for (var i = 0; i < len; i++) {
    var result = _Json_runHelp(decoder, value[i]);
    if (!$gren_lang$core$Result$isOk(result)) {
      return $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$Index({ index: i, error: result.a }));
    }
    array[i] = result.a;
  }
  return $gren_lang$core$Result$Ok(array);
}

function _Json_isArray(value) {
  return (
    Array.isArray(value) ||
    (typeof FileList !== "undefined" && value instanceof FileList)
  );
}

function _Json_expecting(type, value) {
  return $gren_lang$core$Result$Err(
    $gren_lang$core$Json$Decode$Failure({
      message: "Expecting " + type,
      value: _Json_wrap(value),
    }),
  );
}

// EQUALITY

function _Json_equality(x, y) {
  if (x === y) {
    return true;
  }

  if (x.$ !== y.$) {
    return false;
  }

  switch (x.$) {
    case 0:
    case 1:
      return x.a === y.a;

    case 2:
      return x.b === y.b;

    case 4:
      return x.c === y.c;

    case 3:
    case 7:
      return _Json_equality(x.b, y.b);

    case 5:
      return (
        x.d === y.d && _Json_equality(x.b, y.b)
      );

    case 6:
      return (
        x.e === y.e && _Json_equality(x.b, y.b)
      );

    case 8:
      return (
        x.f === y.f && _Json_arrayEquality(x.g, y.g)
      );

    case 9:
      return (
        x.h === y.h &&
        _Json_equality(x.b, y.b)
      );

    case 10:
      return _Json_arrayEquality(x.g, y.g);
  }
}

function _Json_arrayEquality(aDecoders, bDecoders) {
  var len = aDecoders.length;
  if (len !== bDecoders.length) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    if (!_Json_equality(aDecoders[i], bDecoders[i])) {
      return false;
    }
  }
  return true;
}

// ENCODE

var _Json_encode = F2(function (indentLevel, value) {
  return JSON.stringify(_Json_unwrap(value), null, indentLevel) + "";
});

function _Json_wrap(value) {
  return { $: 0, a: value };
}
function _Json_unwrap(value) {
  return value.a;
}

function _Json_wrap_UNUSED(value) {
  return value;
}
function _Json_unwrap_UNUSED(value) {
  return value;
}

function _Json_emptyArray() {
  return [];
}
function _Json_emptyObject() {
  return {};
}

var _Json_addField = F3(function (key, value, object) {
  object[key] = _Json_unwrap(value);
  return object;
});

function _Json_addEntry(func) {
  return F2(function (entry, array) {
    array.push(_Json_unwrap(func(entry)));
    return array;
  });
}

var _Json_encodeNull = _Json_wrap(null);
var $gren_lang$core$Json$Decode$Failure = function (a) {
	return { $: 'Failure', a: a };
};
var $gren_lang$core$Json$Decode$Field = function (a) {
	return { $: 'Field', a: a };
};
var $gren_lang$core$Json$Decode$Index = function (a) {
	return { $: 'Index', a: a };
};
var $gren_lang$core$Json$Decode$OneOf = function (a) {
	return { $: 'OneOf', a: a };
};


// MATH

var _Basics_add = F2(function (a, b) {
  return a + b;
});
var _Basics_sub = F2(function (a, b) {
  return a - b;
});
var _Basics_mul = F2(function (a, b) {
  return a * b;
});
var _Basics_fdiv = F2(function (a, b) {
  return a / b;
});
var _Basics_idiv = F2(function (a, b) {
  return Math.trunc(a / b);
});
var _Basics_pow = F2(Math.pow);

// MORE MATH

function _Basics_toFloat(x) {
  return x;
}
function _Basics_isInfinite(n) {
  return n === Infinity || n === -Infinity;
}

var _Basics_isNaN = isNaN;

// BOOLEANS

function _Basics_not(bool) {
  return !bool;
}
var _Basics_and = F2(function (a, b) {
  return a && b;
});
var _Basics_or = F2(function (a, b) {
  return a || b;
});
var _Basics_xor = F2(function (a, b) {
  return a !== b;
});
var $gren_lang$core$Basics$add = _Basics_add;
var $gren_lang$core$String$any = _String_any;
var $gren_lang$core$Basics$not = _Basics_not;
var $gren_lang$core$String$all$ = function(isGood, str) {
	return !A2($gren_lang$core$String$any, $gren_lang$core$Basics$composeL$($gren_lang$core$Basics$not, isGood), str);
};
var $gren_lang$core$String$all = F2($gren_lang$core$String$all$);
var $gren_lang$core$Basics$and = _Basics_and;
var $gren_lang$core$Json$Encode$encode = _Json_encode;
var $gren_lang$core$String$fromInt = _String_fromNumber;
var $gren_lang$core$Json$Decode$indent = function(str) {
	return A2($gren_lang$core$String$join, '\n    ', A2($gren_lang$core$String$split, '\n', str));
};
var $gren_lang$core$Array$indexedMap = _Array_indexedMap;
var $gren_lang$core$Basics$le = _Utils_le;


function _Char_toCode(char) {
  return char.codePointAt(0);
}

function _Char_fromCode(code) {
  return _Utils_chr(String.fromCodePoint(code));
}
var $gren_lang$core$Char$toCode = _Char_toCode;
var $gren_lang$core$Char$isLower = function(_char) {
	var code = $gren_lang$core$Char$toCode(_char);
	return (97 <= code) && (code <= 122);
};
var $gren_lang$core$Char$isUpper = function(_char) {
	var code = $gren_lang$core$Char$toCode(_char);
	return (code <= 90) && (65 <= code);
};
var $gren_lang$core$Basics$or = _Basics_or;
var $gren_lang$core$Char$isAlpha = function(_char) {
	return $gren_lang$core$Char$isLower(_char) || $gren_lang$core$Char$isUpper(_char);
};
var $gren_lang$core$Char$isDigit = function(_char) {
	var code = $gren_lang$core$Char$toCode(_char);
	return (code <= 57) && (48 <= code);
};
var $gren_lang$core$Char$isAlphaNum = function(_char) {
	return $gren_lang$core$Char$isLower(_char) || ($gren_lang$core$Char$isUpper(_char) || $gren_lang$core$Char$isDigit(_char));
};
var $gren_lang$core$String$popFirst = _String_popFirst;
var $gren_lang$core$Json$Decode$errorOneOf$ = function(i, error) {
	return '\n\n(' + ($gren_lang$core$String$fromInt(i + 1) + (') ' + $gren_lang$core$Json$Decode$indent($gren_lang$core$Json$Decode$errorToString(error))));
};
var $gren_lang$core$Json$Decode$errorOneOf = F2($gren_lang$core$Json$Decode$errorOneOf$);
var $gren_lang$core$Json$Decode$errorToString = function(error) {
	return $gren_lang$core$Json$Decode$errorToStringHelp$(error, [  ]);
};
var $gren_lang$core$Json$Decode$errorToStringHelp$ = function(error, context) {
	errorToStringHelp:
	while (true) {
		switch (error.$) {
			case 'Field':
				var _v1 = error.a;
				var f = _v1.name;
				var err = _v1.error;
				var isSimple = function () {
					var _v2 = $gren_lang$core$String$popFirst(f);
					if (_v2.$ === 'Nothing') {
						return false;
					} else {
						var _v3 = _v2.a;
						var _char = _v3.first;
						var rest = _v3.rest;
						return $gren_lang$core$Char$isAlpha(_char) && $gren_lang$core$String$all$($gren_lang$core$Char$isAlphaNum, rest);
					}
				}();
				var fieldName = isSimple ? ('.' + f) : ('[\'' + (f + '\']'));
				var $temp$error = err,
				$temp$context = _Utils_ap([ fieldName ], context);
				error = $temp$error;
				context = $temp$context;
				continue errorToStringHelp;
			case 'Index':
				var _v4 = error.a;
				var i = _v4.index;
				var err = _v4.error;
				var indexName = '[' + ($gren_lang$core$String$fromInt(i) + ']');
				var $temp$error = err,
				$temp$context = _Utils_ap([ indexName ], context);
				error = $temp$error;
				context = $temp$context;
				continue errorToStringHelp;
			case 'OneOf':
				var errors = error.a;
				switch (errors.length) {
					case 0:
						return 'Ran into a Json.Decode.oneOf with no possibilities' + function () {
							if (context.length === 0) {
								return '!';
							} else {
								return ' at json' + A2($gren_lang$core$String$join, '', context);
							}
						}();
					case 1:
						var err = errors[0];
						var $temp$error = err,
						$temp$context = context;
						error = $temp$error;
						context = $temp$context;
						continue errorToStringHelp;
					default:
						var starter = function () {
							if (context.length === 0) {
								return 'Json.Decode.oneOf';
							} else {
								return 'The Json.Decode.oneOf at json' + A2($gren_lang$core$String$join, '', context);
							}
						}();
						var introduction = starter + (' failed in the following ' + ($gren_lang$core$String$fromInt($gren_lang$core$Array$length(errors)) + ' ways:'));
						return A2($gren_lang$core$String$join, '\n\n', _Utils_ap([ introduction ], A2($gren_lang$core$Array$indexedMap, $gren_lang$core$Json$Decode$errorOneOf, errors)));
				}
			default:
				var _v8 = error.a;
				var msg = _v8.message;
				var json = _v8.value;
				var introduction = function () {
					if (context.length === 0) {
						return 'Problem with the given value:\n\n';
					} else {
						return 'Problem with the value at json' + (A2($gren_lang$core$String$join, '', context) + ':\n\n    ');
					}
				}();
				return introduction + ($gren_lang$core$Json$Decode$indent(A2($gren_lang$core$Json$Encode$encode, 4, json)) + ('\n\n' + msg));
		}
	}
};
var $gren_lang$core$Json$Decode$errorToStringHelp = F2($gren_lang$core$Json$Decode$errorToStringHelp$);
var $gren_lang$core$Basics$True = { $: 'True' };
var $gren_lang$core$Result$isOk = function(result) {
	if (result.$ === 'Ok') {
		return true;
	} else {
		return false;
	}
};


function _Process_sleep(time) {
  return _Scheduler_binding(function (callback) {
    var id = setTimeout(function () {
      callback(_Scheduler_succeed({}));
    }, time);

    return function () {
      clearTimeout(id);
    };
  });
}
var $gren_lang$node$Node$Arm = { $: 'Arm' };
var $gren_lang$node$Node$Arm64 = { $: 'Arm64' };
var $gren_lang$node$Node$IA32 = { $: 'IA32' };
var $gren_lang$node$Node$Mips = { $: 'Mips' };
var $gren_lang$node$Node$Mipsel = { $: 'Mipsel' };
var $gren_lang$node$Node$PPC = { $: 'PPC' };
var $gren_lang$node$Node$PPC64 = { $: 'PPC64' };
var $gren_lang$node$Node$S390 = { $: 'S390' };
var $gren_lang$node$Node$S390x = { $: 'S390x' };
var $gren_lang$node$Node$UnknownArchitecture = function (a) {
	return { $: 'UnknownArchitecture', a: a };
};
var $gren_lang$node$Node$X64 = { $: 'X64' };
var $gren_lang$core$String$toLower = _String_toLower;
var $gren_lang$node$Node$archFromString = function(arch) {
	var _v0 = $gren_lang$core$String$toLower(arch);
	switch (_v0) {
		case 'arm':
			return $gren_lang$node$Node$Arm;
		case 'arm64':
			return $gren_lang$node$Node$Arm64;
		case 'ia32':
			return $gren_lang$node$Node$IA32;
		case 'mips':
			return $gren_lang$node$Node$Mips;
		case 'mipsel':
			return $gren_lang$node$Node$Mipsel;
		case 'ppc':
			return $gren_lang$node$Node$PPC;
		case 'ppc64':
			return $gren_lang$node$Node$PPC64;
		case 's390':
			return $gren_lang$node$Node$S390;
		case 's390x':
			return $gren_lang$node$Node$S390x;
		case 'x64':
			return $gren_lang$node$Node$X64;
		default:
			return $gren_lang$node$Node$UnknownArchitecture(arch);
	}
};
var $gren_lang$core$Task$succeed = _Scheduler_succeed;
var $gren_lang$core$Task$map$ = function(func, taskA) {
	return A2($gren_lang$core$Task$andThen, function(a) {
			return $gren_lang$core$Task$succeed(func(a));
		}, taskA);
};
var $gren_lang$core$Task$map = F2($gren_lang$core$Task$map$);
var $gren_lang$node$Node$Aix = { $: 'Aix' };
var $gren_lang$node$Node$Darwin = { $: 'Darwin' };
var $gren_lang$node$Node$FreeBSD = { $: 'FreeBSD' };
var $gren_lang$node$Node$Linux = { $: 'Linux' };
var $gren_lang$node$Node$OpenBSD = { $: 'OpenBSD' };
var $gren_lang$node$Node$SunOS = { $: 'SunOS' };
var $gren_lang$node$Node$UnknownPlatform = function (a) {
	return { $: 'UnknownPlatform', a: a };
};
var $gren_lang$node$Node$Win32 = { $: 'Win32' };
var $gren_lang$node$Node$platformFromString = function(platform) {
	var _v0 = $gren_lang$core$String$toLower(platform);
	switch (_v0) {
		case 'win32':
			return $gren_lang$node$Node$Win32;
		case 'darwin':
			return $gren_lang$node$Node$Darwin;
		case 'linux':
			return $gren_lang$node$Node$Linux;
		case 'freebsd':
			return $gren_lang$node$Node$FreeBSD;
		case 'openbsd':
			return $gren_lang$node$Node$OpenBSD;
		case 'sunos':
			return $gren_lang$node$Node$SunOS;
		case 'aix':
			return $gren_lang$node$Node$Aix;
		default:
			return $gren_lang$node$Node$UnknownPlatform(platform);
	}
};
var $gren_lang$node$Node$initializeEnvironment = $gren_lang$core$Task$map$(function(raw) {
		return { applicationPath: raw.applicationPath, args: raw.args, cpuArchitecture: $gren_lang$node$Node$archFromString(raw.arch), platform: $gren_lang$node$Node$platformFromString(raw.platform), stderr: raw.stderr, stdin: raw.stdin, stdout: raw.stdout };
	}, _Node_init);
var $gren_lang$core$Platform$Cmd$batch = _Platform_batch;
var $gren_lang$core$Platform$Cmd$none = $gren_lang$core$Platform$Cmd$batch([  ]);
var $gren_lang$core$Platform$Sub$batch = _Platform_batch;
var $gren_lang$core$Platform$Sub$none = $gren_lang$core$Platform$Sub$batch([  ]);
var $gren_lang$core$Task$Perform = function (a) {
	return { $: 'Perform', a: a };
};
var $gren_lang$core$Task$init = $gren_lang$core$Task$succeed({  });
var $gren_lang$core$Array$map = _Array_map;
var $gren_lang$core$Array$foldr = _Array_foldr;
var $gren_lang$core$Task$map2$ = function(func, taskA, taskB) {
	return A2($gren_lang$core$Task$andThen, function(a) {
			return A2($gren_lang$core$Task$andThen, function(b) {
					return $gren_lang$core$Task$succeed(A2(func, a, b));
				}, taskB);
		}, taskA);
};
var $gren_lang$core$Task$map2 = F3($gren_lang$core$Task$map2$);
var $gren_lang$core$Array$pushFirst$ = function(value, array) {
	return A4(_Array_splice1, 0, 0, value, array);
};
var $gren_lang$core$Array$pushFirst = F2($gren_lang$core$Array$pushFirst$);
var $gren_lang$core$Task$sequence = function(tasks) {
	return A3($gren_lang$core$Array$foldr, $gren_lang$core$Task$map2($gren_lang$core$Array$pushFirst), $gren_lang$core$Task$succeed([  ]), tasks);
};
var $gren_lang$core$Platform$sendToApp = _Platform_sendToApp;
var $gren_lang$core$Task$spawnCmd$ = function(router, cmd) {
	if (cmd.$ === 'Perform') {
		var task = cmd.a;
		return _Scheduler_spawn(A2($gren_lang$core$Task$andThen, $gren_lang$core$Platform$sendToApp(router), task));
	} else {
		var task = cmd.a;
		return _Scheduler_spawn(task);
	}
};
var $gren_lang$core$Task$spawnCmd = F2($gren_lang$core$Task$spawnCmd$);
var $gren_lang$core$Task$onEffects$ = function(router, commands, state) {
	return $gren_lang$core$Task$map$(function(_v0) {
			return {  };
		}, $gren_lang$core$Task$sequence(A2($gren_lang$core$Array$map, $gren_lang$core$Task$spawnCmd(router), commands)));
};
var $gren_lang$core$Task$onEffects = F3($gren_lang$core$Task$onEffects$);
var $gren_lang$core$Task$onSelfMsg$ = function(_v0, _v1, _v2) {
	return $gren_lang$core$Task$succeed({  });
};
var $gren_lang$core$Task$onSelfMsg = F3($gren_lang$core$Task$onSelfMsg$);
var $gren_lang$core$Task$Execute = function (a) {
	return { $: 'Execute', a: a };
};
var $gren_lang$core$Task$cmdMap$ = function(tagger, cmd) {
	if (cmd.$ === 'Perform') {
		var task = cmd.a;
		return $gren_lang$core$Task$Perform($gren_lang$core$Task$map$(tagger, task));
	} else {
		var task = cmd.a;
		return $gren_lang$core$Task$Execute(task);
	}
};
var $gren_lang$core$Task$cmdMap = F2($gren_lang$core$Task$cmdMap$);
_Platform_effectManagers['Task'] = _Platform_createManager($gren_lang$core$Task$init, $gren_lang$core$Task$onEffects, $gren_lang$core$Task$onSelfMsg, $gren_lang$core$Task$cmdMap);
var $gren_lang$core$Task$command = _Platform_leaf('Task');
var $gren_lang$core$Task$perform$ = function(toMessage, task) {
	return $gren_lang$core$Task$command($gren_lang$core$Task$Perform($gren_lang$core$Task$map$(toMessage, task)));
};
var $gren_lang$core$Task$perform = F2($gren_lang$core$Task$perform$);
var $gren_lang$node$Node$unwrap = function(_v0) {
	var task = _v0.a;
	return task;
};
var $gren_lang$node$Node$Initialized = function (a) {
	return { $: 'Initialized', a: a };
};
var $gren_lang$node$Node$MsgReceived = function (a) {
	return { $: 'MsgReceived', a: a };
};
var $gren_lang$core$Platform$Cmd$map = _Platform_map;
var $gren_lang$node$Node$update$ = function(appUpdate, msg, model) {
	if (model.$ === 'Uninitialized') {
		if (msg.$ === 'InitDone') {
			var initResult = msg.a;
			return { command: A2($gren_lang$core$Platform$Cmd$map, $gren_lang$node$Node$MsgReceived, initResult.command), model: $gren_lang$node$Node$Initialized(initResult.model) };
		} else {
			return { command: $gren_lang$core$Platform$Cmd$none, model: model };
		}
	} else {
		var appModel = model.a;
		if (msg.$ === 'InitDone') {
			return { command: $gren_lang$core$Platform$Cmd$none, model: model };
		} else {
			var appMsg = msg.a;
			var updateResult = A2(appUpdate, appMsg, appModel);
			return { command: A2($gren_lang$core$Platform$Cmd$map, $gren_lang$node$Node$MsgReceived, updateResult.command), model: $gren_lang$node$Node$Initialized(updateResult.model) };
		}
	}
};
var $gren_lang$node$Node$update = F3($gren_lang$node$Node$update$);
var $gren_lang$core$Platform$worker = _Platform_worker;
var $gren_lang$node$Node$defineSimpleProgram = function(initTask) {
	return $gren_lang$core$Platform$worker({ init: function(_v0) {
			return { command: $gren_lang$core$Task$perform$(function(cmd) {
					return $gren_lang$node$Node$InitDone({ command: cmd, model: {  } });
				}, A2($gren_lang$core$Task$andThen, function(env) {
						return $gren_lang$node$Node$unwrap(initTask(env));
					}, $gren_lang$node$Node$initializeEnvironment)), model: $gren_lang$node$Node$Uninitialized };
		}, subscriptions: function(_v1) {
			return $gren_lang$core$Platform$Sub$none;
		}, update: $gren_lang$node$Node$update(F2(function(_v2, _v3) {
					return { command: $gren_lang$core$Platform$Cmd$none, model: {  } };
				})) });
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready = function (a) {
	return { $: 'Ready', a: a };
};
var $gren_lang$test$Test$Runner$Failure$BadDescription = { $: 'BadDescription' };
var $gren_lang$test$Test$Runner$Failure$DuplicatedName = { $: 'DuplicatedName' };
var $gren_lang$test$Test$Runner$Failure$EmptyArray = { $: 'EmptyArray' };
var $gren_lang$test$Test$Internal$GrenTestVariant__Batch = function (a) {
	return { $: 'GrenTestVariant__Batch', a: a };
};
var $gren_lang$test$Test$Internal$GrenTestVariant__Labeled = function (a) {
	return { $: 'GrenTestVariant__Labeled', a: a };
};
var $gren_lang$test$Test$Runner$Failure$Invalid = function (a) {
	return { $: 'Invalid', a: a };
};
var $gren_lang$core$Set$Set_gren_builtin = function (a) {
	return { $: 'Set_gren_builtin', a: a };
};
var $gren_lang$core$Set$empty = $gren_lang$core$Set$Set_gren_builtin($gren_lang$core$Dict$empty);
var $gren_lang$core$Array$foldl = _Array_foldl;
var $gren_lang$core$Dict$isEmpty = function(dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Set$isEmpty = function(_v0) {
	var dict = _v0.a;
	return $gren_lang$core$Dict$isEmpty(dict);
};
var $gren_lang$core$Array$mapAndFlatten = _Array_flatMap;
var $gren_lang$core$Dict$member$ = function(key, dict) {
	var _v0 = $gren_lang$core$Dict$get$(key, dict);
	if (_v0.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Dict$member = F2($gren_lang$core$Dict$member$);
var $gren_lang$core$Set$member$ = function(key, _v0) {
	var dict = _v0.a;
	return $gren_lang$core$Dict$member$(key, dict);
};
var $gren_lang$core$Set$member = F2($gren_lang$core$Set$member$);
var $gren_lang$core$Set$set$ = function(key, _v0) {
	var dict = _v0.a;
	return $gren_lang$core$Set$Set_gren_builtin($gren_lang$core$Dict$set$(key, {  }, dict));
};
var $gren_lang$core$Set$set = F2($gren_lang$core$Set$set$);
var $gren_lang$test$Test$Internal$duplicatedName = function(tests) {
	var names = function(test) {
		names:
		while (true) {
			switch (test.$) {
				case 'GrenTestVariant__Labeled':
					var str = test.a.label;
					return [ str ];
				case 'GrenTestVariant__Batch':
					var subtests = test.a;
					return A2($gren_lang$core$Array$mapAndFlatten, names, subtests);
				case 'GrenTestVariant__UnitTest':
					return [  ];
				case 'GrenTestVariant__FuzzTest':
					return [  ];
				case 'GrenTestVariant__Skipped':
					var subTest = test.a;
					var $temp$test = subTest;
					test = $temp$test;
					continue names;
				default:
					var subTest = test.a;
					var $temp$test = subTest;
					test = $temp$test;
					continue names;
			}
		}
	};
	var accumDuplicates = F2(function(newName, _v2) {
			var dups = _v2.dups;
			var uniques = _v2.uniques;
			return $gren_lang$core$Set$member$(newName, uniques) ? { dups: $gren_lang$core$Set$set$(newName, dups), uniques: uniques } : { dups: dups, uniques: $gren_lang$core$Set$set$(newName, uniques) };
		});
	var _v1 = A3($gren_lang$core$Array$foldl, accumDuplicates, { dups: $gren_lang$core$Set$empty, uniques: $gren_lang$core$Set$empty }, A2($gren_lang$core$Array$mapAndFlatten, names, tests));
	var dupsAccum = _v1.dups;
	var uniquesAccum = _v1.uniques;
	return $gren_lang$core$Set$isEmpty(dupsAccum) ? $gren_lang$core$Result$Ok(uniquesAccum) : $gren_lang$core$Result$Err(dupsAccum);
};
var $gren_lang$test$Test$Internal$GrenTestVariant__UnitTest = function (a) {
	return { $: 'GrenTestVariant__UnitTest', a: a };
};
var $gren_lang$test$Test$Expectation$Fail = function (a) {
	return { $: 'Fail', a: a };
};
var $gren_lang$test$Test$Distribution$NoDistribution = { $: 'NoDistribution' };
var $gren_lang$test$Test$Expectation$fail = function(_v0) {
	var description = _v0.description;
	var reason = _v0.reason;
	return $gren_lang$test$Test$Expectation$Fail({ description: description, distributionReport: $gren_lang$test$Test$Distribution$NoDistribution, given: $gren_lang$core$Maybe$Nothing, reason: reason });
};
var $gren_lang$test$Test$Internal$failNow = function(record) {
	return $gren_lang$test$Test$Internal$GrenTestVariant__UnitTest(function(_v0) {
			return [ $gren_lang$test$Test$Expectation$fail(record) ];
		});
};
var $gren_lang$core$Array$isEmpty = function(array) {
	return $gren_lang$core$Array$length(array) === 0;
};
var $gren_lang$core$String$isEmpty = function(string) {
	return string === '';
};
var $gren_lang$core$String$trim = _String_trim;
var $gren_lang$test$Test$describe$ = function(untrimmedDesc, tests) {
	var desc = $gren_lang$core$String$trim(untrimmedDesc);
	if ($gren_lang$core$String$isEmpty(desc)) {
		return $gren_lang$test$Test$Internal$failNow({ description: 'This `describe` has a blank description. Let\'s give it a useful one!', reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$BadDescription) });
	} else {
		if ($gren_lang$core$Array$isEmpty(tests)) {
			return $gren_lang$test$Test$Internal$failNow({ description: 'This `describe ' + (desc + '` has no tests in it. Let\'s give it some!'), reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$EmptyArray) });
		} else {
			var _v0 = $gren_lang$test$Test$Internal$duplicatedName(tests);
			if (_v0.$ === 'Err') {
				var dups = _v0.a;
				var dupDescription = function(duped) {
					return 'Contains multiple tests named \'' + (duped + '\'. Let\'s rename them so we know which is which.');
				};
				return $gren_lang$test$Test$Internal$GrenTestVariant__Labeled({ label: desc, test: $gren_lang$test$Test$Internal$failNow({ description: A2($gren_lang$core$String$join, '\n', A2($gren_lang$core$Array$map, dupDescription, $gren_lang$core$Set$toArray(dups))), reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$DuplicatedName) }) });
			} else {
				var childrenNames = _v0.a;
				return $gren_lang$core$Set$member$(desc, childrenNames) ? $gren_lang$test$Test$Internal$GrenTestVariant__Labeled({ label: desc, test: $gren_lang$test$Test$Internal$failNow({ description: 'The test \'' + (desc + '\' contains a child test of the same name. Let\'s rename them so we know which is which.'), reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$DuplicatedName) }) }) : $gren_lang$test$Test$Internal$GrenTestVariant__Labeled({ label: desc, test: $gren_lang$test$Test$Internal$GrenTestVariant__Batch(tests) });
			}
		}
	}
};
var $gren_lang$test$Test$describe = F2($gren_lang$test$Test$describe$);
var $gren_lang$test$Test$Runner$Failure$Custom = { $: 'Custom' };
var $gren_lang$test$Expect$fail = function(str) {
	return $gren_lang$test$Test$Expectation$fail({ description: str, reason: $gren_lang$test$Test$Runner$Failure$Custom });
};
var $gren_lang$test$Test$Internal$blankDescriptionFailure = $gren_lang$test$Test$Internal$failNow({ description: 'This test has a blank description. Let\'s give it a useful one!', reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$BadDescription) });
var $gren_lang$test$Test$test$ = function(untrimmedDesc, thunk) {
	var desc = $gren_lang$core$String$trim(untrimmedDesc);
	return $gren_lang$core$String$isEmpty(desc) ? $gren_lang$test$Test$Internal$blankDescriptionFailure : $gren_lang$test$Test$Internal$GrenTestVariant__Labeled({ label: desc, test: $gren_lang$test$Test$Internal$GrenTestVariant__UnitTest(function(_v0) {
				return [ thunk({  }) ];
			}) });
};
var $gren_lang$test$Test$test = F2($gren_lang$test$Test$test$);
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$unwrap = function(internalTest) {
	if (internalTest.$ === 'Ready') {
		var t = internalTest.a;
		return t;
	} else {
		return $gren_lang$test$Test$test$('Unexpected error', function(_v1) {
				return $gren_lang$test$Expect$fail('Oops! Something weird happened and you reached a point in\nthe code that I thought was unreachable. Congrats! But\nalso... sorry about that. It would be great if you could\nopen an issue so I can figure out how this happened:\nhttps://github.com/blaix/gren-effectful-tests-node/issues\nPlease include the test(s) that triggered this error.');
			});
	}
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$ = function(description, tests) {
	return $gren_lang$core$Task$map$($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready, $gren_lang$core$Task$map$($gren_lang$test$Test$describe(description), $gren_lang$core$Task$sequence(A2($gren_lang$core$Array$map, $gren_lang$core$Task$map($blaix$gren_effectful_tests_node$Test$Runner$Effectful$unwrap), tests))));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe = F2($blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$);
var $gren_lang$core$Array$slice = _Array_slice;
var $gren_lang$core$Array$dropFirst$ = function(n, array) {
	return A3($gren_lang$core$Array$slice, n, $gren_lang$core$Array$length(array), array);
};
var $gren_lang$core$Array$dropFirst = F2($gren_lang$core$Array$dropFirst$);
var $gren_lang$node$HttpClient$AnyPermission = { $: 'AnyPermission' };
var $gren_lang$node$HttpClient$initialize = $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$succeed($gren_lang$node$HttpClient$AnyPermission));
var $gren_lang$compiler_node$CLI$PrettyPrinter$Block = function (a) {
	return { $: 'Block', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$block = function(docs) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Block(docs);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$ = function(clr, doc) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Colorized({ color: clr, document: doc, intense: true });
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor = F2($gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$);
var $gren_lang$core$Dict$mapAndKeepJust$ = function(toMaybe, dict) {
	return $gren_lang$core$Dict$foldl$(F3(function(k, v, d) {
				var _v0 = A2(toMaybe, k, v);
				if (_v0.$ === 'Just') {
					var newValue = _v0.a;
					return $gren_lang$core$Dict$set$(k, newValue, d);
				} else {
					return d;
				}
			}), $gren_lang$core$Dict$empty, dict);
};
var $gren_lang$core$Dict$mapAndKeepJust = F2($gren_lang$core$Dict$mapAndKeepJust$);
var $gren_lang$compiler_node$CLI$Parser$appHelpText = function(appDef) {
	var _v0 = appDef.commands;
	var knownCommands = _v0.a.knownCommands;
	var commonCommands = $gren_lang$core$Dict$mapAndKeepJust$(F2(function(_v1, commonDescription) {
				return commonDescription;
			}), knownCommands);
	var knownCommandsDocument = $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock(A2($gren_lang$core$Array$map, function(command) {
							return $gren_lang$compiler_node$CLI$PrettyPrinter$text(appDef.name + (' ' + command));
						}, $gren_lang$core$Dict$keys(knownCommands))))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$block([ $gren_lang$compiler_node$CLI$PrettyPrinter$text('Adding the '), $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--help')), $gren_lang$compiler_node$CLI$PrettyPrinter$text(' flag gives you more details about a specific command.') ]) ]);
	var commandBlock = $gren_lang$core$Dict$isEmpty(commonCommands) ? $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('In order to do something useful, you need to give me a command. Here\'s a full list:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, knownCommandsDocument ]) : $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('The most common commands are:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock($gren_lang$core$Dict$foldl$(F3(function(name, description, acc) {
							return $gren_lang$core$Array$pushLast$($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text(appDef.name + (' ' + name))), $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words(description)), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]), acc);
						}), [  ], commonCommands))), $gren_lang$compiler_node$CLI$PrettyPrinter$words('There are a bunch of other commands as well though. Here is a full list:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, knownCommandsDocument ]);
	return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ appDef.intro, $gren_lang$compiler_node$CLI$PrettyPrinter$empty, commandBlock, $gren_lang$compiler_node$CLI$PrettyPrinter$empty, appDef.outro, $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
};
var $gren_lang$core$String$slice = _String_slice;
var $gren_lang$core$String$unitLength = _String_unitLength;
var $gren_lang$core$String$dropFirst$ = function(n, string) {
	return (n < 1) ? string : A3($gren_lang$core$String$slice, n, $gren_lang$core$String$unitLength(string), string);
};
var $gren_lang$core$String$dropFirst = F2($gren_lang$core$String$dropFirst$);
var $gren_lang$core$Array$takeFirst$ = function(n, array) {
	return A3($gren_lang$core$Array$slice, 0, n, array);
};
var $gren_lang$core$Array$takeFirst = F2($gren_lang$core$Array$takeFirst$);
var $gren_lang$compiler_node$CLI$Parser$buildFlagDict = function(flags) {
	return A3($gren_lang$core$Array$foldl, F2(function(rawFlag, dict) {
				var flagParts = $gren_lang$core$Array$takeFirst$(2, A2($gren_lang$core$String$split, '=', $gren_lang$core$String$dropFirst$(2, rawFlag)));
				switch (flagParts.length) {
					case 1:
						var key = flagParts[0];
						return $gren_lang$core$Dict$set$(key, '', dict);
					case 2:
						var key = flagParts[0];
						var value = flagParts[1];
						return $gren_lang$core$Dict$set$(key, value, dict);
					default:
						return dict;
				}
			}), $gren_lang$core$Dict$empty, flags);
};
var $gren_lang$core$Array$partition$ = function(fn, array) {
	return A3($gren_lang$core$Array$foldl, F2(function(val, _v0) {
				var trues = _v0.trues;
				var falses = _v0.falses;
				return fn(val) ? { falses: falses, trues: $gren_lang$core$Array$pushLast$(val, trues) } : { falses: $gren_lang$core$Array$pushLast$(val, falses), trues: trues };
			}), { falses: [  ], trues: [  ] }, array);
};
var $gren_lang$core$Array$partition = F2($gren_lang$core$Array$partition$);
var $gren_lang$core$Array$get = _Array_get;
var $gren_lang$core$Array$first = function(array) {
	return A2($gren_lang$core$Array$get, 0, array);
};
var $gren_lang$core$Array$popFirst = function(array) {
	var _v0 = $gren_lang$core$Array$first(array);
	if (_v0.$ === 'Just') {
		var value = _v0.a;
		return $gren_lang$core$Maybe$Just({ first: value, rest: $gren_lang$core$Array$dropFirst$(1, array) });
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$core$String$startsWith = _String_startsWith;
var $gren_lang$compiler_node$CLI$Parser$run$ = function(tokens, appDef) {
	var _v0 = appDef.commands;
	var parse = _v0.a.parseFn;
	var _v1 = $gren_lang$core$Array$partition$(function(word) {
			return A2($gren_lang$core$String$startsWith, '--', word);
		}, tokens);
	var flags = _v1.trues;
	var _arguments = _v1.falses;
	if ((flags.length === 1) && (flags[0] === '--version')) {
		return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$PrettyPrinter$text(appDef.version));
	} else {
		var _v3 = $gren_lang$core$Array$popFirst(_arguments);
		if (_v3.$ === 'Just') {
			var _v4 = _v3.a;
			var command = _v4.first;
			var args = _v4.rest;
			return A4(parse, appDef.name, command, args, $gren_lang$compiler_node$CLI$Parser$buildFlagDict(flags));
		} else {
			return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$Parser$appHelpText(appDef));
		}
	}
};
var $gren_lang$compiler_node$CLI$Parser$run = F2($gren_lang$compiler_node$CLI$Parser$run$);
var $gren_lang$node$Init$awaitTask$ = function(task, fn) {
	return $gren_lang$node$Internal$Init$Task(A2($gren_lang$core$Task$andThen, $gren_lang$core$Basics$composeL$($gren_lang$node$Init$unwrap, fn), task));
};
var $gren_lang$node$Init$awaitTask = F2($gren_lang$node$Init$awaitTask$);
var $gren_lang$core$Random$Seed = function (a) {
	return { $: 'Seed', a: a };
};
var $gren_lang$core$Basics$mul = _Basics_mul;


var _Bitwise_and = F2(function (a, b) {
  return a & b;
});

var _Bitwise_or = F2(function (a, b) {
  return a | b;
});

var _Bitwise_xor = F2(function (a, b) {
  return a ^ b;
});

function _Bitwise_complement(a) {
  return ~a;
}

var _Bitwise_countLeadingZeros = Math.clz32;

var _Bitwise_shiftLeftBy = F2(function (offset, a) {
  return a << offset;
});

var _Bitwise_shiftRightBy = F2(function (offset, a) {
  return a >> offset;
});

var _Bitwise_shiftRightZfBy = F2(function (offset, a) {
  return a >>> offset;
});
var $gren_lang$core$Bitwise$shiftRightZfBy = _Bitwise_shiftRightZfBy;
var $gren_lang$core$Random$next = function(_v0) {
	var _v1 = _v0.a;
	var state0 = _v1.state;
	var incr = _v1.increment;
	return $gren_lang$core$Random$Seed({ increment: incr, state: ((state0 * 1664525) + incr) >>> 0 });
};
var $gren_lang$core$Random$initialSeed = function(x) {
	var _v0 = $gren_lang$core$Random$next($gren_lang$core$Random$Seed({ increment: 1013904223, state: 0 }));
	var _v1 = _v0.a;
	var state1 = _v1.state;
	var incr = _v1.increment;
	var state2 = (state1 + x) >>> 0;
	return $gren_lang$core$Random$next($gren_lang$core$Random$Seed({ increment: incr, state: state2 }));
};


function _Time_now(millisToPosix) {
  return _Scheduler_binding(function (callback) {
    callback(_Scheduler_succeed(millisToPosix(Date.now())));
  });
}

var _Time_setInterval = F2(function (interval, task) {
  return _Scheduler_binding(function (callback) {
    var id = setInterval(function () {
      _Scheduler_rawSpawn(task);
    }, interval);
    return function () {
      clearInterval(id);
    };
  });
});

function _Time_here() {
  return _Scheduler_binding(function (callback) {
    callback(
      _Scheduler_succeed(
        A2($gren_lang$core$Time$customZone, -new Date().getTimezoneOffset(), []),
      ),
    );
  });
}

function _Time_getZoneName() {
  return _Scheduler_binding(function (callback) {
    try {
      var name = $gren_lang$core$Time$Name(Intl.DateTimeFormat().resolvedOptions().timeZone);
    } catch (e) {
      var name = $gren_lang$core$Time$Offset(new Date().getTimezoneOffset());
    }
    callback(_Scheduler_succeed(name));
  });
}
var $gren_lang$core$Time$Name = function (a) {
	return { $: 'Name', a: a };
};
var $gren_lang$core$Time$Offset = function (a) {
	return { $: 'Offset', a: a };
};
var $gren_lang$core$Time$Zone = function (a) {
	return { $: 'Zone', a: a };
};
var $gren_lang$core$Time$customZone$ = function(offset, eras) {
	return $gren_lang$core$Time$Zone({ eras: eras, offset: offset });
};
var $gren_lang$core$Time$customZone = F2($gren_lang$core$Time$customZone$);
var $gren_lang$core$Time$Posix = function (a) {
	return { $: 'Posix', a: a };
};
var $gren_lang$core$Time$millisToPosix = $gren_lang$core$Time$Posix;
var $gren_lang$core$Time$now = _Time_now($gren_lang$core$Time$millisToPosix);
var $gren_lang$core$Time$posixToMillis = function(_v0) {
	var millis = _v0.a;
	return millis;
};
var $gren_lang$core$Task$execute = function(task) {
	return $gren_lang$core$Task$command($gren_lang$core$Task$Execute($gren_lang$core$Task$map$(function(_v0) {
					return {  };
				}, task)));
};
var $gren_lang$node$Node$endSimpleProgram = function(finalTask) {
	return $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$succeed($gren_lang$core$Task$execute(finalTask)));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$getColorDepth = function(config) {
	if (config.$ === 'Just') {
		var colorDepth = config.a.colorDepth;
		return colorDepth;
	} else {
		return 1;
	}
};


var process = require("node:process");

var _Terminal_init = _Scheduler_binding(function (callback) {
  callback(
    _Scheduler_succeed({
      isTTY: process.stdout.isTTY,
      colorDepth: process.stdout.getColorDepth
        ? process.stdout.getColorDepth()
        : 0,
      columns: process.stdout.columns,
      rows: process.stdout.rows,
    }),
  );
});

var _Terminal_attachListener = function (sendToApp) {
  return _Scheduler_binding(function (_callback) {
    var listener = function (data) {
      _Scheduler_rawSpawn(
        sendToApp({
          columns: process.stdout.columns,
          rows: process.stdout.rows,
        }),
      );
    };

    process.stdout.on("resize", listener);

    return function () {
      process.stdout.off("resize", listener);
      process.stdout.pause();
    };
  });
};

var _Terminal_setStdInRawMode = function (toggle) {
  return _Scheduler_binding(function (callback) {
    process.stdin.setRawMode(toggle);
    callback(_Scheduler_succeed({}));
  });
};

var _Terminal_setProcessTitle = function (title) {
  return _Scheduler_binding(function (callback) {
    process.title = title;
    callback(_Scheduler_succeed({}));
  });
};
var $gren_lang$node$Terminal$Permission = { $: 'Permission' };
var $gren_lang$node$Terminal$initialize = $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$map$(function(raw) {
			return raw.isTTY ? $gren_lang$core$Maybe$Just({ colorDepth: raw.colorDepth, columns: raw.columns, permission: $gren_lang$node$Terminal$Permission, rows: raw.rows }) : $gren_lang$core$Maybe$Nothing;
		}, _Terminal_init));
var $gren_lang$node$Node$exitWithCode = function(code) {
	return _Node_exitWithCode(code);
};
var $gren_lang$core$Basics$gt = _Utils_gt;
var $gren_lang$core$Task$onError = _Scheduler_onError;
var $gren_lang$test$Test$Runner$Invalid = function (a) {
	return { $: 'Invalid', a: a };
};
var $gren_lang$test$Test$Runner$Only = function (a) {
	return { $: 'Only', a: a };
};
var $gren_lang$test$Test$Runner$Plain = function (a) {
	return { $: 'Plain', a: a };
};
var $gren_lang$test$Test$Runner$Skipping = function (a) {
	return { $: 'Skipping', a: a };
};
var $gren_lang$core$Basics$composeR$ = function(f, g) {
	return function(x) {
		return g(f(x));
	};
};
var $gren_lang$core$Basics$composeR = F2($gren_lang$core$Basics$composeR$);
var $gren_lang$test$Test$Runner$countRunnables = function(runnable) {
	countRunnables:
	while (true) {
		if (runnable.$ === 'Runnable') {
			return 1;
		} else {
			var runner = runnable.a.tree;
			var $temp$runnable = runner;
			runnable = $temp$runnable;
			continue countRunnables;
		}
	}
};
var $gren_lang$test$Test$Runner$countAllRunnables = A2($gren_lang$core$Array$foldl, $gren_lang$core$Basics$composeR$($gren_lang$test$Test$Runner$countRunnables, $gren_lang$core$Basics$add), 0);
var $gren_lang$test$Test$Runner$Labeled = function (a) {
	return { $: 'Labeled', a: a };
};
var $gren_lang$test$Test$Runner$Runnable = function (a) {
	return { $: 'Runnable', a: a };
};
var $gren_lang$test$Test$Runner$Thunk = function (a) {
	return { $: 'Thunk', a: a };
};
var $gren_lang$test$Test$Runner$emptyDistribution = function(seed) {
	return { all: [  ], only: [  ], seed: seed, skipped: [  ] };
};
var $gren_lang$core$Bitwise$xor = _Bitwise_xor;
var $gren_lang$test$Test$Runner$fnvHash$ = function(a, b) {
	return ((a ^ b) * 16777619) >>> 0;
};
var $gren_lang$test$Test$Runner$fnvHash = F2($gren_lang$test$Test$Runner$fnvHash$);
var $gren_lang$core$String$foldl = _String_foldl;
var $gren_lang$core$String$toArray = function(string) {
	return A3($gren_lang$core$String$foldl, $gren_lang$core$Array$pushLast, [  ], string);
};
var $gren_lang$test$Test$Runner$fnvHashString$ = function(hash, str) {
	return A3($gren_lang$core$Array$foldl, $gren_lang$test$Test$Runner$fnvHash, hash, A2($gren_lang$core$Array$map, $gren_lang$core$Char$toCode, $gren_lang$core$String$toArray(str)));
};
var $gren_lang$test$Test$Runner$fnvHashString = F2($gren_lang$test$Test$Runner$fnvHashString$);
var $gren_lang$test$Test$Runner$fnvInit = 2166136261;
var $gren_lang$core$Random$Generator = function (a) {
	return { $: 'Generator', a: a };
};
var $gren_lang$core$Bitwise$and = _Bitwise_and;
var $gren_lang$core$Basics$negate = function(n) {
	return -n;
};
var $gren_lang$core$Random$peel = function(_v0) {
	var state = _v0.a.state;
	var word = (state ^ (state >>> ((state >>> 28) + 4))) * 277803737;
	return ((word >>> 22) ^ word) >>> 0;
};


// MATH

var _Math_remainderBy = F2(function (b, a) {
  return a % b;
});

// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
var _Math_modBy = F2(function (modulus, x) {
  var answer = x % modulus;
  return modulus === 0
    ? _Debug_crash(11)
    : (answer > 0 && modulus < 0) || (answer < 0 && modulus > 0)
      ? answer + modulus
      : answer;
});

// CONSTANTS

var _Math_pi = Math.PI;
var _Math_e = Math.E;
var _Math_maxSafeInteger = Number.MAX_SAFE_INTEGER;
var _Math_minSafeInteger = Number.MIN_SAFE_INTEGER;
var _Math_maxFloat = Number.MAX_VALUE;

// TRIGONOMETRY

var _Math_cos = Math.cos;
var _Math_sin = Math.sin;
var _Math_tan = Math.tan;
var _Math_acos = Math.acos;
var _Math_asin = Math.asin;
var _Math_atan = Math.atan;
var _Math_atan2 = F2(Math.atan2);

// MORE MATH

var _Math_truncate = Math.trunc;
var _Math_ceiling = Math.ceil;
var _Math_floor = Math.floor;
var _Math_round = Math.round;
var _Math_sqrt = Math.sqrt;
var _Math_log = Math.log;
var _Math_log10 = Math.log10;
var $gren_lang$core$Math$remainderBy = _Math_remainderBy;
var $gren_lang$core$Basics$sub = _Basics_sub;
var $gren_lang$core$Random$int$ = function(a, b) {
	return $gren_lang$core$Random$Generator(function(seed0) {
			var _v0 = (_Utils_cmp(a, b) < 0) ? { hi: b, lo: a } : { hi: a, lo: b };
			var lo = _v0.lo;
			var hi = _v0.hi;
			var range = (hi - lo) + 1;
			if (((range - 1) & range) === 0) {
				return { seed: $gren_lang$core$Random$next(seed0), value: (((range - 1) & $gren_lang$core$Random$peel(seed0)) >>> 0) + lo };
			} else {
				var threshhold = (((-range) >>> 0) % range) >>> 0;
				var accountForBias = function(seed) {
					accountForBias:
					while (true) {
						var x = $gren_lang$core$Random$peel(seed);
						var seedN = $gren_lang$core$Random$next(seed);
						if (_Utils_cmp(x, threshhold) < 0) {
							var $temp$seed = seedN;
							seed = $temp$seed;
							continue accountForBias;
						} else {
							return { seed: seedN, value: (x % range) + lo };
						}
					}
				};
				return accountForBias(seed0);
			}
		});
};
var $gren_lang$core$Random$int = F2($gren_lang$core$Random$int$);
var $gren_lang$core$Random$map3$ = function(func, _v0, _v1, _v2) {
	var genA = _v0.a;
	var genB = _v1.a;
	var genC = _v2.a;
	return $gren_lang$core$Random$Generator(function(seed0) {
			var _v3 = genA(seed0);
			var a = _v3.value;
			var seed1 = _v3.seed;
			var _v4 = genB(seed1);
			var b = _v4.value;
			var seed2 = _v4.seed;
			var _v5 = genC(seed2);
			var c = _v5.value;
			var seed3 = _v5.seed;
			return { seed: seed3, value: A3(func, a, b, c) };
		});
};
var $gren_lang$core$Random$map3 = F4($gren_lang$core$Random$map3$);
var $gren_lang$core$Bitwise$or = _Bitwise_or;
var $gren_lang$core$Random$step$ = function(_v0, seed) {
	var generator = _v0.a;
	return generator(seed);
};
var $gren_lang$core$Random$step = F2($gren_lang$core$Random$step$);
var $gren_lang$core$Random$independentSeed = $gren_lang$core$Random$Generator(function(seed0) {
		var makeIndependentSeed = F3(function(state, b, c) {
				return $gren_lang$core$Random$next($gren_lang$core$Random$Seed({ increment: (1 | (b ^ c)) >>> 0, state: state }));
			});
		var gen = $gren_lang$core$Random$int$(0, 4294967295);
		return $gren_lang$core$Random$step$($gren_lang$core$Random$map3$(makeIndependentSeed, gen, gen, gen), seed0);
	});
var $gren_lang$core$Random$maxInt = 2147483647;
var $gren_lang$test$Test$Runner$batchDistribute$ = function(hashed, runs, test, prev) {
	var next = $gren_lang$test$Test$Runner$distributeSeedsHelp$(hashed, runs, prev.seed, test);
	return { all: _Utils_ap(prev.all, next.all), only: _Utils_ap(prev.only, next.only), seed: next.seed, skipped: _Utils_ap(prev.skipped, next.skipped) };
};
var $gren_lang$test$Test$Runner$batchDistribute = F4($gren_lang$test$Test$Runner$batchDistribute$);
var $gren_lang$test$Test$Runner$distributeSeedsHelp$ = function(hashed, runs, seed, test) {
	switch (test.$) {
		case 'GrenTestVariant__UnitTest':
			var aRun = test.a;
			return { all: [ $gren_lang$test$Test$Runner$Runnable($gren_lang$test$Test$Runner$Thunk(function(_v1) {
						return aRun({  });
					})) ], only: [  ], seed: seed, skipped: [  ] };
		case 'GrenTestVariant__FuzzTest':
			var aRun = test.a;
			var _v2 = $gren_lang$core$Random$step$($gren_lang$core$Random$independentSeed, seed);
			var firstSeed = _v2.value;
			var nextSeed = _v2.seed;
			return { all: [ $gren_lang$test$Test$Runner$Runnable($gren_lang$test$Test$Runner$Thunk(function(_v3) {
						return A2(aRun, firstSeed, runs);
					})) ], only: [  ], seed: nextSeed, skipped: [  ] };
		case 'GrenTestVariant__Labeled':
			var _v4 = test.a;
			var description = _v4.label;
			var subTest = _v4.test;
			if (hashed) {
				var next = $gren_lang$test$Test$Runner$distributeSeedsHelp$(true, runs, seed, subTest);
				return { all: A2($gren_lang$core$Array$map, function(t) {
						return $gren_lang$test$Test$Runner$Labeled({ label: description, tree: t });
					}, next.all), only: A2($gren_lang$core$Array$map, function(t) {
						return $gren_lang$test$Test$Runner$Labeled({ label: description, tree: t });
					}, next.only), seed: next.seed, skipped: A2($gren_lang$core$Array$map, function(t) {
						return $gren_lang$test$Test$Runner$Labeled({ label: description, tree: t });
					}, next.skipped) };
			} else {
				var intFromSeed = $gren_lang$core$Random$step$($gren_lang$core$Random$int$(0, $gren_lang$core$Random$maxInt), seed).value;
				var hashedSeed = $gren_lang$core$Random$initialSeed($gren_lang$test$Test$Runner$fnvHash$(intFromSeed, $gren_lang$test$Test$Runner$fnvHashString$($gren_lang$test$Test$Runner$fnvInit, description)));
				var next = $gren_lang$test$Test$Runner$distributeSeedsHelp$(true, runs, hashedSeed, subTest);
				return { all: A2($gren_lang$core$Array$map, function(t) {
						return $gren_lang$test$Test$Runner$Labeled({ label: description, tree: t });
					}, next.all), only: A2($gren_lang$core$Array$map, function(t) {
						return $gren_lang$test$Test$Runner$Labeled({ label: description, tree: t });
					}, next.only), seed: seed, skipped: A2($gren_lang$core$Array$map, function(t) {
						return $gren_lang$test$Test$Runner$Labeled({ label: description, tree: t });
					}, next.skipped) };
			}
		case 'GrenTestVariant__Skipped':
			var subTest = test.a;
			var next = $gren_lang$test$Test$Runner$distributeSeedsHelp$(hashed, runs, seed, subTest);
			return { all: [  ], only: [  ], seed: next.seed, skipped: next.all };
		case 'GrenTestVariant__Only':
			var subTest = test.a;
			var next = $gren_lang$test$Test$Runner$distributeSeedsHelp$(hashed, runs, seed, subTest);
			return _Utils_update(next, { only: next.all });
		default:
			var tests = test.a;
			return A3($gren_lang$core$Array$foldl, A2($gren_lang$test$Test$Runner$batchDistribute, hashed, runs), $gren_lang$test$Test$Runner$emptyDistribution(seed), tests);
	}
};
var $gren_lang$test$Test$Runner$distributeSeedsHelp = F4($gren_lang$test$Test$Runner$distributeSeedsHelp$);
var $gren_lang$test$Test$Runner$distributeSeeds = $gren_lang$test$Test$Runner$distributeSeedsHelp(false);



function _Test_runThunk(thunk)
{
  try {
    // Attempt to run the thunk as normal.
    return $gren_lang$core$Result$Ok(thunk({}));
  } catch (err) {
    // If it throws, return an error instead of crashing.
    return $gren_lang$core$Result$Err(err.toString());
  }
}
var $gren_lang$test$Test$Runner$runThunk = _Test_runThunk;
var $gren_lang$test$Test$Runner$run = function(_v0) {
	var fn = _v0.a;
	var _v1 = $gren_lang$test$Test$Runner$runThunk(fn);
	if (_v1.$ === 'Ok') {
		var test = _v1.a;
		return test;
	} else {
		var message = _v1.a;
		return [ $gren_lang$test$Expect$fail('This test failed because it threw an exception: \"' + (message + '\"')) ];
	}
};
var $gren_lang$test$Test$Runner$fromRunnableTreeHelp$ = function(labels, runner) {
	fromRunnableTreeHelp:
	while (true) {
		if (runner.$ === 'Runnable') {
			var runnable = runner.a;
			return [ { labels: labels, run: function(_v1) {
				return $gren_lang$test$Test$Runner$run(runnable);
			} } ];
		} else {
			var _v2 = runner.a;
			var label = _v2.label;
			var subRunner = _v2.tree;
			var $temp$labels = $gren_lang$core$Array$pushFirst$(label, labels),
			$temp$runner = subRunner;
			labels = $temp$labels;
			runner = $temp$runner;
			continue fromRunnableTreeHelp;
		}
	}
};
var $gren_lang$test$Test$Runner$fromRunnableTreeHelp = F2($gren_lang$test$Test$Runner$fromRunnableTreeHelp$);
var $gren_lang$test$Test$Runner$fromRunnableTree = $gren_lang$test$Test$Runner$fromRunnableTreeHelp([  ]);
var $gren_lang$test$Test$Runner$fromTest$ = function(runs, seed, test) {
	if (runs < 1) {
		return $gren_lang$test$Test$Runner$Invalid('Test runner run count must be at least 1, not ' + $gren_lang$core$String$fromInt(runs));
	} else {
		var distribution = A3($gren_lang$test$Test$Runner$distributeSeeds, runs, seed, test);
		return $gren_lang$core$Array$isEmpty(distribution.only) ? (($gren_lang$test$Test$Runner$countAllRunnables(distribution.skipped) === 0) ? $gren_lang$test$Test$Runner$Plain(A2($gren_lang$core$Array$mapAndFlatten, $gren_lang$test$Test$Runner$fromRunnableTree, distribution.all)) : $gren_lang$test$Test$Runner$Skipping(A2($gren_lang$core$Array$mapAndFlatten, $gren_lang$test$Test$Runner$fromRunnableTree, distribution.all))) : $gren_lang$test$Test$Runner$Only(A2($gren_lang$core$Array$mapAndFlatten, $gren_lang$test$Test$Runner$fromRunnableTree, distribution.only));
	}
};
var $gren_lang$test$Test$Runner$fromTest = F3($gren_lang$test$Test$Runner$fromTest$);
var $gren_lang$core$String$pushFirst = _String_pushFirst;
var $gren_lang$core$String$fromChar = function(_char) {
	return A2($gren_lang$core$String$pushFirst, _char, '');
};
var $gren_lang$core$Char$fromCode = _Char_fromCode;
var $gren_lang$core$Basics$idiv = _Basics_idiv;
var $gren_lang$test$Test$Runner$String$Format$hexInt = function(_int) {
	if (_int === 0) {
		return '0';
	} else {
		var zeroPad4 = function(n) {
			zeroPad4:
			while (true) {
				if ($gren_lang$core$String$unitLength(n) < 4) {
					var $temp$n = '0' + n;
					n = $temp$n;
					continue zeroPad4;
				} else {
					return n;
				}
			}
		};
		var hexIntInternal = function(i) {
			return (i === 0) ? '' : _Utils_ap(hexIntInternal((i / 16) | 0), function () {
					var _v0 = i % 16;
					switch (_v0) {
						case 10:
							return 'a';
						case 11:
							return 'b';
						case 12:
							return 'c';
						case 13:
							return 'd';
						case 14:
							return 'e';
						case 15:
							return 'f';
						default:
							var decimalDigit = _v0;
							return $gren_lang$core$String$fromInt(decimalDigit);
					}
				}());
		};
		return zeroPad4(hexIntInternal(_int));
	}
};
var $gren_lang$core$Array$findFirst = _Array_findFirst;
var $gren_lang$core$Array$member$ = function(value, array) {
	var _v0 = A2($gren_lang$core$Array$findFirst, function(v) {
			return _Utils_eq(v, value);
		}, array);
	if (_v0.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Array$member = F2($gren_lang$core$Array$member$);
var $gren_lang$test$Test$Runner$String$Format$escapeUnicodeChars = function(s) {
	var isAsciiChar = function(v) {
		return ((32 <= v) && (v <= 125)) && ($gren_lang$core$Array$member$(v, [ 94, 96 ]) === false);
	};
	return A2($gren_lang$core$String$join, '', A2($gren_lang$core$Array$map, function(c) {
				return isAsciiChar(c) ? $gren_lang$core$String$fromChar($gren_lang$core$Char$fromCode(c)) : ('\\u{' + ($gren_lang$test$Test$Runner$String$Format$hexInt(c) + '}'));
			}, A2($gren_lang$core$Array$map, $gren_lang$core$Char$toCode, $gren_lang$core$String$toArray(s))));
};
var $gren_lang$test$Test$Runner$String$Format$collectPairs = function(arr) {
	return A3($gren_lang$core$Array$foldl, F2(function(_v0, acc) {
				var first = _v0.first;
				var second = _v0.second;
				return { firsts: $gren_lang$core$Array$pushLast$(first, acc.firsts), seconds: $gren_lang$core$Array$pushLast$(second, acc.seconds) };
			}), { firsts: [  ], seconds: [  ] }, arr);
};
var $gren_lang$test$Diff$arrayClassicGet$ = function(index, array) {
	return (index < 0) ? $gren_lang$core$Maybe$Nothing : A2($gren_lang$core$Array$get, index, array);
};
var $gren_lang$test$Diff$arrayClassicGet = F2($gren_lang$test$Diff$arrayClassicGet$);
var $gren_lang$test$Diff$Added = function (a) {
	return { $: 'Added', a: a };
};
var $gren_lang$test$Diff$CannotGetA = function (a) {
	return { $: 'CannotGetA', a: a };
};
var $gren_lang$test$Diff$CannotGetB = function (a) {
	return { $: 'CannotGetB', a: a };
};
var $gren_lang$test$Diff$NoChange = function (a) {
	return { $: 'NoChange', a: a };
};
var $gren_lang$test$Diff$Removed = function (a) {
	return { $: 'Removed', a: a };
};
var $gren_lang$test$Diff$UnexpectedPath = function (a) {
	return { $: 'UnexpectedPath', a: a };
};
var $gren_lang$test$Diff$makeChangesHelp$ = function(changes, getA, getB, _v0, path) {
	makeChangesHelp:
	while (true) {
		var x = _v0.x;
		var y = _v0.y;
		var _v1 = $gren_lang$core$Array$popFirst(path);
		if (_v1.$ === 'Nothing') {
			return $gren_lang$core$Result$Ok(changes);
		} else {
			var _v2 = _v1.a;
			var _v3 = _v2.first;
			var prevX = _v3.x;
			var prevY = _v3.y;
			var tail = _v2.rest;
			var change = function () {
				if (_Utils_eq(x - 1, prevX) && _Utils_eq(y - 1, prevY)) {
					var _v5 = getA(x);
					if (_v5.$ === 'Just') {
						var a = _v5.a;
						return $gren_lang$core$Result$Ok($gren_lang$test$Diff$NoChange(a));
					} else {
						return $gren_lang$core$Result$Err($gren_lang$test$Diff$CannotGetA(x));
					}
				} else {
					if (_Utils_eq(x, prevX)) {
						var _v6 = getB(y);
						if (_v6.$ === 'Just') {
							var b = _v6.a;
							return $gren_lang$core$Result$Ok($gren_lang$test$Diff$Added(b));
						} else {
							return $gren_lang$core$Result$Err($gren_lang$test$Diff$CannotGetB(y));
						}
					} else {
						if (_Utils_eq(y, prevY)) {
							var _v7 = getA(x);
							if (_v7.$ === 'Just') {
								var a = _v7.a;
								return $gren_lang$core$Result$Ok($gren_lang$test$Diff$Removed(a));
							} else {
								return $gren_lang$core$Result$Err($gren_lang$test$Diff$CannotGetA(x));
							}
						} else {
							return $gren_lang$core$Result$Err($gren_lang$test$Diff$UnexpectedPath({ path: path, pos: { x: x, y: y } }));
						}
					}
				}
			}();
			if (change.$ === 'Ok') {
				var c = change.a;
				var $temp$changes = $gren_lang$core$Array$pushFirst$(c, changes),
				$temp$getA = getA,
				$temp$getB = getB,
				$temp$_v0 = { x: prevX, y: prevY },
				$temp$path = tail;
				changes = $temp$changes;
				getA = $temp$getA;
				getB = $temp$getB;
				_v0 = $temp$_v0;
				path = $temp$path;
				continue makeChangesHelp;
			} else {
				var e = change.a;
				return $gren_lang$core$Result$Err(e);
			}
		}
	}
};
var $gren_lang$test$Diff$makeChangesHelp = F5($gren_lang$test$Diff$makeChangesHelp$);
var $gren_lang$test$Diff$makeChanges$ = function(getA, getB, path) {
	var _v0 = $gren_lang$core$Array$popFirst(path);
	if (_v0.$ === 'Nothing') {
		return $gren_lang$core$Result$Ok([  ]);
	} else {
		var _v1 = _v0.a;
		var latest = _v1.first;
		var tail = _v1.rest;
		return $gren_lang$test$Diff$makeChangesHelp$([  ], getA, getB, latest, tail);
	}
};
var $gren_lang$test$Diff$makeChanges = F3($gren_lang$test$Diff$makeChanges$);
var $gren_lang$core$Array$initialize = _Array_initialize;
var $gren_lang$test$Diff$Continue = function (a) {
	return { $: 'Continue', a: a };
};
var $gren_lang$test$Diff$Found = function (a) {
	return { $: 'Found', a: a };
};
var $gren_lang$core$Basics$ge = _Utils_ge;
var $gren_lang$core$Array$set = _Array_set;
var $gren_lang$core$Maybe$withDefault$ = function(_default, maybe) {
	if (maybe.$ === 'Just') {
		var value = maybe.a;
		return value;
	} else {
		return _default;
	}
};
var $gren_lang$core$Maybe$withDefault = F2($gren_lang$core$Maybe$withDefault$);
var $gren_lang$test$Diff$step$ = function(snake_, offset, k, v) {
	var fromTop = $gren_lang$core$Maybe$withDefault$([  ], $gren_lang$test$Diff$arrayClassicGet$((k + 1) + offset, v));
	var fromLeft = $gren_lang$core$Maybe$withDefault$([  ], $gren_lang$test$Diff$arrayClassicGet$((k - 1) + offset, v));
	var _v0 = function () {
		var _v2 = { l: $gren_lang$core$Array$popFirst(fromLeft), t: $gren_lang$core$Array$popFirst(fromTop) };
		if (_v2.l.$ === 'Nothing') {
			if (_v2.t.$ === 'Nothing') {
				var _v3 = _v2.l;
				var _v4 = _v2.t;
				return { path: [  ], point: { x: 0, y: 0 } };
			} else {
				var _v5 = _v2.l;
				var _v6 = _v2.t.a.first;
				var topX = _v6.x;
				var topY = _v6.y;
				return { path: fromTop, point: { x: topX + 1, y: topY } };
			}
		} else {
			if (_v2.t.$ === 'Nothing') {
				var _v7 = _v2.l.a.first;
				var leftX = _v7.x;
				var leftY = _v7.y;
				var _v8 = _v2.t;
				return { path: fromLeft, point: { x: leftX, y: leftY + 1 } };
			} else {
				var _v9 = _v2.l.a.first;
				var leftX = _v9.x;
				var leftY = _v9.y;
				var _v10 = _v2.t.a.first;
				var topX = _v10.x;
				var topY = _v10.y;
				return (_Utils_cmp(leftY + 1, topY) > -1) ? { path: fromLeft, point: { x: leftX, y: leftY + 1 } } : { path: fromTop, point: { x: topX + 1, y: topY } };
			}
		}
	}();
	var path = _v0.path;
	var _v1 = _v0.point;
	var x = _v1.x;
	var y = _v1.y;
	var _v11 = A3(snake_, x + 1, y + 1, $gren_lang$core$Array$pushFirst$({ x: x, y: y }, path));
	var newPath = _v11.array;
	var goal = _v11.result;
	return goal ? $gren_lang$test$Diff$Found(newPath) : $gren_lang$test$Diff$Continue(A3($gren_lang$core$Array$set, k + offset, newPath, v));
};
var $gren_lang$test$Diff$step = F4($gren_lang$test$Diff$step$);
var $gren_lang$test$Diff$onpLoopK$ = function(snake_, offset, ks, v) {
	onpLoopK:
	while (true) {
		var _v0 = $gren_lang$core$Array$popFirst(ks);
		if (_v0.$ === 'Nothing') {
			return $gren_lang$test$Diff$Continue(v);
		} else {
			var _v1 = _v0.a;
			var k = _v1.first;
			var ks_ = _v1.rest;
			var _v2 = $gren_lang$test$Diff$step$(snake_, offset, k, v);
			if (_v2.$ === 'Found') {
				var path = _v2.a;
				return $gren_lang$test$Diff$Found(path);
			} else {
				var v_ = _v2.a;
				var $temp$snake_ = snake_,
				$temp$offset = offset,
				$temp$ks = ks_,
				$temp$v = v_;
				snake_ = $temp$snake_;
				offset = $temp$offset;
				ks = $temp$ks;
				v = $temp$v;
				continue onpLoopK;
			}
		}
	}
};
var $gren_lang$test$Diff$onpLoopK = F4($gren_lang$test$Diff$onpLoopK$);
var $gren_lang$core$Array$range$ = function(from, to) {
	return (_Utils_cmp(from, to) > 0) ? [  ] : (_Utils_eq(from, to) ? [ from ] : A3($gren_lang$core$Array$initialize, (to - from) + 1, from, $gren_lang$core$Basics$identity));
};
var $gren_lang$core$Array$range = F2($gren_lang$core$Array$range$);
var $gren_lang$core$Array$reverse = _Array_reverse;
var $gren_lang$test$Diff$onpLoopP$ = function(snake_, delta, offset, p, v) {
	onpLoopP:
	while (true) {
		var ks = (delta > 0) ? _Utils_ap($gren_lang$core$Array$reverse($gren_lang$core$Array$range$(delta + 1, delta + p)), $gren_lang$core$Array$range$(-p, delta)) : _Utils_ap($gren_lang$core$Array$reverse($gren_lang$core$Array$range$(delta + 1, p)), $gren_lang$core$Array$range$((-p) + delta, delta));
		var _v0 = $gren_lang$test$Diff$onpLoopK$(snake_, offset, ks, v);
		if (_v0.$ === 'Found') {
			var path = _v0.a;
			return path;
		} else {
			var v_ = _v0.a;
			var $temp$snake_ = snake_,
			$temp$delta = delta,
			$temp$offset = offset,
			$temp$p = p + 1,
			$temp$v = v_;
			snake_ = $temp$snake_;
			delta = $temp$delta;
			offset = $temp$offset;
			p = $temp$p;
			v = $temp$v;
			continue onpLoopP;
		}
	}
};
var $gren_lang$test$Diff$onpLoopP = F5($gren_lang$test$Diff$onpLoopP$);
var $gren_lang$test$Diff$snake$ = function(getA, getB, nextX, nextY, path) {
	snake:
	while (true) {
		var _v0 = { l: getA(nextX), r: getB(nextY) };
		_v0$2:
		while (true) {
			if (_v0.l.$ === 'Just') {
				if (_v0.r.$ === 'Just') {
					var a = _v0.l.a;
					var b = _v0.r.a;
					if (_Utils_eq(a, b)) {
						var $temp$getA = getA,
						$temp$getB = getB,
						$temp$nextX = nextX + 1,
						$temp$nextY = nextY + 1,
						$temp$path = $gren_lang$core$Array$pushFirst$({ x: nextX, y: nextY }, path);
						getA = $temp$getA;
						getB = $temp$getB;
						nextX = $temp$nextX;
						nextY = $temp$nextY;
						path = $temp$path;
						continue snake;
					} else {
						return { array: path, result: false };
					}
				} else {
					break _v0$2;
				}
			} else {
				if (_v0.r.$ === 'Nothing') {
					var _v1 = _v0.l;
					var _v2 = _v0.r;
					return { array: path, result: true };
				} else {
					break _v0$2;
				}
			}
		}
		return { array: path, result: false };
	}
};
var $gren_lang$test$Diff$snake = F5($gren_lang$test$Diff$snake$);
var $gren_lang$test$Diff$onp$ = function(getA, getB, m, n) {
	var v = A3($gren_lang$core$Array$initialize, (m + n) + 1, 0, function(_v0) {
			return [  ];
		});
	var delta = n - m;
	return $gren_lang$test$Diff$onpLoopP$(A2($gren_lang$test$Diff$snake, getA, getB), delta, m, 0, v);
};
var $gren_lang$test$Diff$onp = F4($gren_lang$test$Diff$onp$);
var $gren_lang$test$Diff$testDiff$ = function(a, b) {
	var n = $gren_lang$core$Array$length(b);
	var m = $gren_lang$core$Array$length(a);
	var getB = function(y) {
		return $gren_lang$test$Diff$arrayClassicGet$(y - 1, b);
	};
	var getA = function(x) {
		return $gren_lang$test$Diff$arrayClassicGet$(x - 1, a);
	};
	var path = $gren_lang$test$Diff$onp$(getA, getB, m, n);
	return $gren_lang$test$Diff$makeChanges$(getA, getB, path);
};
var $gren_lang$test$Diff$testDiff = F2($gren_lang$test$Diff$testDiff$);
var $gren_lang$test$Diff$diff$ = function(a, b) {
	var _v0 = $gren_lang$test$Diff$testDiff$(a, b);
	if (_v0.$ === 'Ok') {
		var changes = _v0.a;
		return changes;
	} else {
		return [  ];
	}
};
var $gren_lang$test$Diff$diff = F2($gren_lang$test$Diff$diff$);
var $gren_lang$test$Test$Runner$String$Format$formatActualChange = function(diff) {
	switch (diff.$) {
		case 'Added':
			return { first: '', second: '' };
		case 'Removed':
			var _char = diff.a;
			return { first: '', second: $gren_lang$core$String$fromChar(_char) };
		default:
			var _char = diff.a;
			return { first: ' ', second: $gren_lang$core$String$fromChar(_char) };
	}
};
var $gren_lang$test$Test$Runner$String$Format$formatExpectedChange = function(diff) {
	switch (diff.$) {
		case 'Added':
			return { first: '', second: '' };
		case 'Removed':
			var _char = diff.a;
			return { first: $gren_lang$core$String$fromChar(_char), second: '' };
		default:
			var _char = diff.a;
			return { first: $gren_lang$core$String$fromChar(_char), second: ' ' };
	}
};
var $gren_lang$test$Test$Runner$String$Format$formatEqualityDiffArrows$ = function(below, above) {
	if (_Utils_cmp($gren_lang$core$String$unitLength(below) * $gren_lang$core$String$unitLength(above), 300 * 300) > 0) {
		return { above: { arrows: [ ' -- skipping diffing because input is too large' ], value: [ above ] }, below: { arrows: [ ' -- skipping diffing because input is too large' ], value: [ below ] } };
	} else {
		var _v0 = $gren_lang$test$Test$Runner$String$Format$collectPairs(A2($gren_lang$core$Array$map, $gren_lang$test$Test$Runner$String$Format$formatActualChange, $gren_lang$test$Diff$diff$($gren_lang$core$String$toArray(above), $gren_lang$core$String$toArray(below))));
		var diffArrowsAbove = _v0.firsts;
		var valueAbove = _v0.seconds;
		var _v1 = $gren_lang$test$Test$Runner$String$Format$collectPairs(A2($gren_lang$core$Array$map, $gren_lang$test$Test$Runner$String$Format$formatExpectedChange, $gren_lang$test$Diff$diff$($gren_lang$core$String$toArray(below), $gren_lang$core$String$toArray(above))));
		var valueBelow = _v1.firsts;
		var diffArrowsBelow = _v1.seconds;
		return { above: { arrows: diffArrowsAbove, value: valueAbove }, below: { arrows: diffArrowsBelow, value: valueBelow } };
	}
};
var $gren_lang$test$Test$Runner$String$Format$formatEqualityDiffArrows = F2($gren_lang$test$Test$Runner$String$Format$formatEqualityDiffArrows$);
var $gren_lang$test$Test$Runner$String$Format$verticalBar$ = function(comparison, below, above) {
	return A2($gren_lang$core$String$join, '\n', [ above, '', ' |> ' + comparison, '', below ]);
};
var $gren_lang$test$Test$Runner$String$Format$verticalBar = F3($gren_lang$test$Test$Runner$String$Format$verticalBar$);
var $gren_lang$test$Test$Runner$String$Format$equalityToString = function(_v0) {
	var operation = _v0.operation;
	var expected = _v0.expected;
	var actual = _v0.actual;
	var combine = function(things) {
		return A2($gren_lang$core$String$join, '\n', A2($gren_lang$core$Array$map, $gren_lang$core$String$join(''), things));
	};
	var _v1 = $gren_lang$test$Test$Runner$String$Format$formatEqualityDiffArrows$(expected, actual);
	var _v2 = _v1.below;
	var valueBelow = _v2.value;
	var diffArrowsBelow = _v2.arrows;
	var _v3 = _v1.above;
	var diffArrowsAbove = _v3.arrows;
	var valueAbove = _v3.value;
	var _v4 = $gren_lang$test$Test$Runner$String$Format$formatEqualityDiffArrows$($gren_lang$test$Test$Runner$String$Format$escapeUnicodeChars(expected), $gren_lang$test$Test$Runner$String$Format$escapeUnicodeChars(actual));
	var _v5 = _v4.below;
	var unicodeValueBelow = _v5.value;
	var unicodeDiffArrowsBelow = _v5.arrows;
	var _v6 = _v4.above;
	var unicodeDiffArrowsAbove = _v6.arrows;
	var unicodeValueAbove = _v6.value;
	return $gren_lang$test$Test$Runner$String$Format$verticalBar$(operation, (!_Utils_eq(A2($gren_lang$core$String$join, '', valueBelow), A2($gren_lang$core$String$join, '', unicodeValueBelow))) ? combine([ valueBelow, diffArrowsBelow, _Utils_ap(unicodeValueBelow, [ ' (same string but with unicode characters escaped)' ]), unicodeDiffArrowsBelow ]) : combine([ valueBelow, diffArrowsBelow ]), (!_Utils_eq(A2($gren_lang$core$String$join, '', valueAbove), A2($gren_lang$core$String$join, '', unicodeValueAbove))) ? combine([ unicodeDiffArrowsAbove, _Utils_ap(unicodeValueAbove, [ ' (same string but with unicode characters escaped)' ]), diffArrowsAbove, valueAbove ]) : combine([ diffArrowsAbove, valueAbove ]));
};
var $gren_lang$core$Debug$toString = _Debug_toString;
var $gren_lang$test$Test$Runner$String$Format$listDiffToString$ = function(index, description, _v0, originals) {
	listDiffToString:
	while (true) {
		var expected = _v0.expected;
		var actual = _v0.actual;
		var _v1 = { l: $gren_lang$core$Array$popFirst(expected), r: $gren_lang$core$Array$popFirst(actual) };
		if (_v1.l.$ === 'Nothing') {
			if (_v1.r.$ === 'Nothing') {
				var _v2 = _v1.l;
				var _v3 = _v1.r;
				return A2($gren_lang$core$String$join, '', [ 'Two lists were unequal previously, yet ended up equal later.', 'This should never happen!', 'Please report this bug to https://github.com/gren-lang/test/issues - and include these lists: ', '\n', $gren_lang$core$Debug$toString(originals.originalExpected), '\n', $gren_lang$core$Debug$toString(originals.originalActual) ]);
			} else {
				var _v5 = _v1.l;
				return $gren_lang$test$Test$Runner$String$Format$verticalBar$(description + ' was longer than', $gren_lang$core$Debug$toString(originals.originalExpected), $gren_lang$core$Debug$toString(originals.originalActual));
			}
		} else {
			if (_v1.r.$ === 'Nothing') {
				var _v4 = _v1.r;
				return $gren_lang$test$Test$Runner$String$Format$verticalBar$(description + ' was shorter than', $gren_lang$core$Debug$toString(originals.originalExpected), $gren_lang$core$Debug$toString(originals.originalActual));
			} else {
				var _v6 = _v1.l.a;
				var firstExpected = _v6.first;
				var restExpected = _v6.rest;
				var _v7 = _v1.r.a;
				var firstActual = _v7.first;
				var restActual = _v7.rest;
				if (_Utils_eq(firstExpected, firstActual)) {
					var $temp$index = index + 1,
					$temp$description = description,
					$temp$_v0 = { actual: restActual, expected: restExpected },
					$temp$originals = originals;
					index = $temp$index;
					description = $temp$description;
					_v0 = $temp$_v0;
					originals = $temp$originals;
					continue listDiffToString;
				} else {
					return A2($gren_lang$core$String$join, '', [ $gren_lang$test$Test$Runner$String$Format$verticalBar$(description, $gren_lang$core$Debug$toString(originals.originalExpected), $gren_lang$core$Debug$toString(originals.originalActual)), '\n\nThe first diff is at index ', $gren_lang$core$Debug$toString(index), ': it was `', firstActual, '`, but `', firstExpected, '` was expected.' ]);
				}
			}
		}
	}
};
var $gren_lang$test$Test$Runner$String$Format$listDiffToString = F4($gren_lang$test$Test$Runner$String$Format$listDiffToString$);
var $gren_lang$test$Test$Runner$String$Format$format$ = function(description, reason) {
	switch (reason.$) {
		case 'Custom':
			return description;
		case 'Equality':
			var _v1 = reason.a;
			var expected = _v1.expected;
			var actual = _v1.actual;
			return $gren_lang$test$Test$Runner$String$Format$equalityToString({ actual: actual, expected: expected, operation: description });
		case 'Comparison':
			var _v2 = reason.a;
			var expected = _v2.expected;
			var actual = _v2.actual;
			return $gren_lang$test$Test$Runner$String$Format$verticalBar$(description, expected, actual);
		case 'TODO':
			return description;
		case 'Invalid':
			if (reason.a.$ === 'BadDescription') {
				var _v3 = reason.a;
				return (description === '') ? 'The empty string is not a valid test description.' : ('This is an invalid test description: ' + description);
			} else {
				return description;
			}
		case 'ArrayDiff':
			var _v4 = reason.a;
			var expected = _v4.expected;
			var actual = _v4.actual;
			return $gren_lang$test$Test$Runner$String$Format$listDiffToString$(0, description, { actual: actual, expected: expected }, { originalActual: actual, originalExpected: expected });
		default:
			var _v5 = reason.a;
			var expected = _v5.expected;
			var actual = _v5.actual;
			var extra = _v5.extra;
			var missing = _v5.missing;
			var missingStr = $gren_lang$core$Array$isEmpty(missing) ? '' : ('\nThese keys are missing: ' + function(d) {
				return '[ ' + (d + ' ]');
			}(A2($gren_lang$core$String$join, ', ', missing)));
			var extraStr = $gren_lang$core$Array$isEmpty(extra) ? '' : ('\nThese keys are extra: ' + function(d) {
				return '[ ' + (d + ' ]');
			}(A2($gren_lang$core$String$join, ', ', extra)));
			return A2($gren_lang$core$String$join, '', [ $gren_lang$test$Test$Runner$String$Format$verticalBar$(description, expected, actual), '\n', extraStr, missingStr ]);
	}
};
var $gren_lang$test$Test$Runner$String$Format$format = F2($gren_lang$test$Test$Runner$String$Format$format$);
var $gren_lang$test$Test$Runner$getDistributionReport = function(expectation) {
	if (expectation.$ === 'Pass') {
		var distributionReport = expectation.a.distributionReport;
		return distributionReport;
	} else {
		var distributionReport = expectation.a.distributionReport;
		return distributionReport;
	}
};
var $gren_lang$test$Test$Runner$getFailureReason = function(expectation) {
	if (expectation.$ === 'Pass') {
		return $gren_lang$core$Maybe$Nothing;
	} else {
		var record = expectation.a;
		return $gren_lang$core$Maybe$Just({ description: record.description, given: record.given, reason: record.reason });
	}
};
var $gren_lang$test$Test$Runner$String$indentLines = function(str) {
	return A2($gren_lang$core$String$join, '\n', A2($gren_lang$core$Array$map, $gren_lang$core$Basics$append('    '), A2($gren_lang$core$String$split, '\n', str)));
};
var $gren_lang$core$Array$keepIf = _Array_filter;
var $gren_lang$test$Test$Runner$formatLabels$ = function(formatDescription, formatTest, labels) {
	var _v0 = $gren_lang$core$Array$popFirst(A2($gren_lang$core$Array$keepIf, $gren_lang$core$Basics$composeL$($gren_lang$core$Basics$not, $gren_lang$core$String$isEmpty), labels));
	if (_v0.$ === 'Nothing') {
		return [  ];
	} else {
		var _v1 = _v0.a;
		var test = _v1.first;
		var descriptions = _v1.rest;
		return $gren_lang$core$Array$reverse($gren_lang$core$Array$pushFirst$(formatTest(test), A2($gren_lang$core$Array$map, formatDescription, descriptions)));
	}
};
var $gren_lang$test$Test$Runner$formatLabels = F3($gren_lang$test$Test$Runner$formatLabels$);
var $gren_lang$test$Test$Runner$String$outputLabels = function(labels) {
	return A2($gren_lang$core$String$join, '\n', $gren_lang$test$Test$Runner$formatLabels$($gren_lang$core$Basics$append(' '), $gren_lang$core$Basics$append(' '), labels));
};
var $gren_lang$core$Basics$fdiv = _Basics_fdiv;
var $gren_lang$test$AsciiTable$AlignLeft = { $: 'AlignLeft' };
var $gren_lang$test$AsciiTable$AlignRight = { $: 'AlignRight' };
var $gren_lang$test$Test$Runner$Distribution$bars = 30;
var $gren_lang$core$String$count = function(string) {
	return A3($gren_lang$core$String$foldl, F2(function(_v0, num) {
				return num + 1;
			}), 0, string);
};
var $gren_lang$core$String$repeat = _String_repeat;
var $gren_lang$core$String$padRight$ = function(n, _char, string) {
	return _Utils_ap(string, A2($gren_lang$core$String$repeat, n - $gren_lang$core$String$count(string), $gren_lang$core$String$fromChar(_char)));
};
var $gren_lang$core$String$padRight = F3($gren_lang$core$String$padRight$);
var $gren_lang$core$Math$round = _Math_round;
var $gren_lang$core$Basics$toFloat = _Basics_toFloat;
var $gren_lang$test$Test$Runner$Distribution$barView = function(_v0) {
	var count = _v0.count;
	var runsElapsed = _v0.runsElapsed;
	var percentage = count / runsElapsed;
	var barsForPercentage = percentage * $gren_lang$test$Test$Runner$Distribution$bars;
	var fullBars = $gren_lang$core$Math$round(barsForPercentage);
	return $gren_lang$core$String$padRight$($gren_lang$test$Test$Runner$Distribution$bars, _Utils_chr(''), A2($gren_lang$core$String$repeat, fullBars, ''));
};
var $gren_lang$core$String$fromFloat = _String_fromNumber;
var $gren_lang$core$Array$map2 = _Array_map2;
var $gren_lang$core$Array$map3 = _Array_map3;
var $gren_lang$core$Array$maximum = function(array) {
	var _v0 = $gren_lang$core$Array$first(array);
	if (_v0.$ === 'Nothing') {
		return $gren_lang$core$Maybe$Nothing;
	} else {
		var val = _v0.a;
		return $gren_lang$core$Maybe$Just(A3($gren_lang$core$Array$foldl, F2(function(current, highest) {
						return (_Utils_cmp(current, highest) > 0) ? current : highest;
					}), val, array));
	}
};
var $gren_lang$core$String$padLeft$ = function(n, _char, string) {
	return _Utils_ap(A2($gren_lang$core$String$repeat, n - $gren_lang$core$String$count(string), $gren_lang$core$String$fromChar(_char)), string);
};
var $gren_lang$core$String$padLeft = F3($gren_lang$core$String$padLeft$);
var $gren_lang$core$Array$repeat$ = function(n, val) {
	return A3($gren_lang$core$Array$initialize, n, 0, function(_v0) {
			return val;
		});
};
var $gren_lang$core$Array$repeat = F2($gren_lang$core$Array$repeat$);
var $gren_lang$test$MicroArrayExtra$rowsLength = function(listOfArrays) {
	var _v0 = $gren_lang$core$Array$first(listOfArrays);
	if (_v0.$ === 'Nothing') {
		return 0;
	} else {
		var x = _v0.a;
		return $gren_lang$core$Array$length(x);
	}
};
var $gren_lang$test$MicroArrayExtra$transpose = function(listOfArrays) {
	return A3($gren_lang$core$Array$foldr, $gren_lang$core$Array$map2($gren_lang$core$Array$pushFirst), $gren_lang$core$Array$repeat$($gren_lang$test$MicroArrayExtra$rowsLength(listOfArrays), [  ]), listOfArrays);
};
var $gren_lang$test$AsciiTable$view$ = function(columns, items) {
	var padFn = F3(function(length, align, string) {
			if (align.$ === 'AlignLeft') {
				return $gren_lang$core$String$padRight$(length, _Utils_chr(' '), string);
			} else {
				return $gren_lang$core$String$padLeft$(length, _Utils_chr(' '), string);
			}
		});
	var columnData = A2($gren_lang$core$Array$map, function(col) {
			return A2($gren_lang$core$Array$map, col.toString, items);
		}, columns);
	var columnLengths = A2($gren_lang$core$Array$map, function(colRows) {
			return $gren_lang$core$Maybe$withDefault$(0, $gren_lang$core$Array$maximum(A2($gren_lang$core$Array$map, $gren_lang$core$String$unitLength, colRows)));
		}, columnData);
	var paddedColumnData = A4($gren_lang$core$Array$map3, F3(function(col, colLength, colStrings) {
				return A2($gren_lang$core$Array$map, A2(padFn, colLength, col.align), colStrings);
			}), columns, columnLengths, columnData);
	return A3($gren_lang$core$Array$map2, F2(function(item, rowCells) {
				return { item: item, renderedRow: A2($gren_lang$core$String$join, '  ', rowCells) };
			}), items, $gren_lang$test$MicroArrayExtra$transpose(paddedColumnData));
};
var $gren_lang$test$AsciiTable$view = F2($gren_lang$test$AsciiTable$view$);
var $gren_lang$test$Test$Runner$Distribution$viewLabels = function(labels) {
	return $gren_lang$core$Array$isEmpty(labels) ? '<uncategorized>' : A2($gren_lang$core$String$join, ', ', labels);
};
var $gren_lang$test$Test$Runner$Distribution$formatAsciiTable$ = function(runsElapsed, items) {
	return $gren_lang$test$AsciiTable$view$([ { align: $gren_lang$test$AsciiTable$AlignLeft, toString: function(_v0) {
			var labels = _v0.labels;
			return '  ' + ($gren_lang$test$Test$Runner$Distribution$viewLabels(labels) + ':');
		} }, { align: $gren_lang$test$AsciiTable$AlignRight, toString: function(_v1) {
			var percentage = _v1.percentage;
			return $gren_lang$core$String$fromFloat(percentage) + '%';
		} }, { align: $gren_lang$test$AsciiTable$AlignRight, toString: function(_v2) {
			var count = _v2.count;
			return '(' + ($gren_lang$core$String$fromInt(count) + 'x)');
		} }, { align: $gren_lang$test$AsciiTable$AlignLeft, toString: function(_v3) {
			var count = _v3.count;
			return $gren_lang$test$Test$Runner$Distribution$barView({ count: count, runsElapsed: runsElapsed });
		} } ], items);
};
var $gren_lang$test$Test$Runner$Distribution$formatAsciiTable = F2($gren_lang$test$Test$Runner$Distribution$formatAsciiTable$);
var $gren_lang$core$Array$any$ = function(fn, array) {
	var _v0 = A2($gren_lang$core$Array$findFirst, fn, array);
	if (_v0.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Array$any = F2($gren_lang$core$Array$any$);
var $gren_lang$core$Dict$diff$ = function(t1, t2) {
	return $gren_lang$core$Dict$foldl$(F3(function(k, v, t) {
				return $gren_lang$core$Dict$remove$(k, t);
			}), t1, t2);
};
var $gren_lang$core$Dict$diff = F2($gren_lang$core$Dict$diff$);
var $gren_lang$core$Set$diff$ = function(_v0, _v1) {
	var dict1 = _v0.a;
	var dict2 = _v1.a;
	return $gren_lang$core$Set$Set_gren_builtin($gren_lang$core$Dict$diff$(dict1, dict2));
};
var $gren_lang$core$Set$diff = F2($gren_lang$core$Set$diff$);
var $gren_lang$core$Set$fromArray = function(array) {
	return A3($gren_lang$core$Array$foldl, $gren_lang$core$Set$set, $gren_lang$core$Set$empty, array);
};
var $gren_lang$test$Test$Runner$Distribution$isStrictSubset$ = function(all, combination) {
	var combinationSet = $gren_lang$core$Set$fromArray(combination);
	var containsCombinationFully = function(set) {
		return (!$gren_lang$core$Set$isEmpty($gren_lang$core$Set$diff$(set, combinationSet))) && $gren_lang$core$Set$isEmpty($gren_lang$core$Set$diff$(combinationSet, set));
	};
	var allSets = A2($gren_lang$core$Array$map, $gren_lang$core$Basics$composeR$(function ($) {
				return $.key;
			}, $gren_lang$core$Set$fromArray), all);
	return $gren_lang$core$Array$any$(containsCombinationFully, allSets);
};
var $gren_lang$test$Test$Runner$Distribution$isStrictSubset = F2($gren_lang$test$Test$Runner$Distribution$isStrictSubset$);
var $gren_lang$core$Array$sortBy = _Array_sortBy;
var $gren_lang$core$Maybe$map$ = function(f, maybe) {
	if (maybe.$ === 'Just') {
		var value = maybe.a;
		return $gren_lang$core$Maybe$Just(f(value));
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$core$Maybe$map = F2($gren_lang$core$Maybe$map$);
var $gren_lang$test$MicroArrayExtra$findIndex$ = function(pred, array) {
	return $gren_lang$core$Maybe$map$(function ($) {
			return $.index;
		}, A2($gren_lang$core$Array$findFirst, pred, array));
};
var $gren_lang$test$MicroArrayExtra$findIndex = F2($gren_lang$test$MicroArrayExtra$findIndex$);
var $gren_lang$test$MicroArrayExtra$splitAt$ = function(n, xs) {
	return { first: $gren_lang$core$Array$takeFirst$(n, xs), last: $gren_lang$core$Array$dropFirst$(n, xs) };
};
var $gren_lang$test$MicroArrayExtra$splitAt = F2($gren_lang$test$MicroArrayExtra$splitAt$);
var $gren_lang$test$MicroArrayExtra$splitWhen$ = function(predicate, list) {
	return $gren_lang$core$Maybe$map$(function(i) {
			return $gren_lang$test$MicroArrayExtra$splitAt$(i, list);
		}, $gren_lang$test$MicroArrayExtra$findIndex$(predicate, list));
};
var $gren_lang$test$MicroArrayExtra$splitWhen = F2($gren_lang$test$MicroArrayExtra$splitWhen$);
var $gren_lang$test$Test$Runner$Distribution$formatTable = function(_v0) {
	var runsElapsed = _v0.runsElapsed;
	var distributionCount = _v0.distributionCount;
	var runsElapsed_ = runsElapsed;
	var distributionArray = $gren_lang$core$Dict$foldl$(F3(function(key, value, array) {
				return $gren_lang$core$Array$pushLast$({ key: key, value: value }, array);
			}), [  ], distributionCount);
	var distribution = A2($gren_lang$core$Array$map, function(_v8) {
			var labels = _v8.key;
			var count = _v8.value;
			var percentage = $gren_lang$core$Math$round((count / runsElapsed_) * 1000) / 10;
			return { count: count, labels: labels, percentage: percentage };
		}, A2($gren_lang$core$Array$keepIf, function(_v7) {
				var labels = _v7.key;
				var count = _v7.value;
				return !(($gren_lang$core$Array$length(labels) === 1) && ((count === 0) && $gren_lang$test$Test$Runner$Distribution$isStrictSubset$(distributionArray, labels)));
			}, distributionArray));
	var _v1 = $gren_lang$core$Array$partition$(function(_v3) {
			var labels = _v3.labels;
			return $gren_lang$core$Array$length(labels) <= 1;
		}, A2($gren_lang$core$Array$sortBy, function(_v2) {
				var count = _v2.count;
				return -count;
			}, distribution));
	var baseRows = _v1.trues;
	var combinationsRows = _v1.falses;
	var reorderedTable = _Utils_ap(baseRows, combinationsRows);
	var rawTable = $gren_lang$test$Test$Runner$Distribution$formatAsciiTable$(runsElapsed_, reorderedTable);
	var _v4 = $gren_lang$core$Maybe$withDefault$({ first: rawTable, last: [  ] }, $gren_lang$test$MicroArrayExtra$splitWhen$(function(_v5) {
				var item = _v5.item;
				var _v6 = item;
				var labels = _v6.labels;
				return $gren_lang$core$Array$length(labels) > 1;
			}, rawTable));
	var base = _v4.first;
	var combinations = _v4.last;
	var baseString = A2($gren_lang$core$String$join, '\n', A2($gren_lang$core$Array$map, function ($) {
				return $.renderedRow;
			}, base));
	var combinationsString_ = $gren_lang$core$Array$isEmpty(combinations) ? '' : function(s) {
		return '\n' + s;
	}($gren_lang$core$String$replace$('{COMBINATIONS}', A2($gren_lang$core$String$join, '\n', A2($gren_lang$core$Array$map, function ($) {
						return $.renderedRow;
					}, combinations)), 'Combinations (included in the above base counts):\n{COMBINATIONS}'));
	var table = _Utils_ap(baseString, combinationsString_);
	return $gren_lang$core$String$replace$('{CATEGORIES}', table, 'Distribution report:\n====================\n{CATEGORIES}');
};
var $gren_lang$test$Test$Distribution$distributionReportTable = function(r) {
	return $gren_lang$test$Test$Runner$Distribution$formatTable(r);
};
var $gren_lang$test$Test$Runner$String$Distribution$report$ = function(testBreadcrumbs, distributionReport) {
	switch (distributionReport.$) {
		case 'NoDistribution':
			return $gren_lang$core$Maybe$Nothing;
		case 'DistributionToReport':
			var r = distributionReport.a;
			var breadcrumbsPath = A2($gren_lang$core$String$join, ' > ', $gren_lang$core$Array$reverse(testBreadcrumbs));
			return $gren_lang$core$Maybe$Just(breadcrumbsPath + ('\n' + $gren_lang$test$Test$Distribution$distributionReportTable(r)));
		case 'DistributionCheckSucceeded':
			return $gren_lang$core$Maybe$Nothing;
		default:
			return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$test$Test$Runner$String$Distribution$report = F2($gren_lang$test$Test$Runner$String$Distribution$report$);
var $gren_lang$test$Test$Runner$String$fromExpectation$ = function(labels, expectation, summary) {
	var distributionReport = $gren_lang$test$Test$Runner$String$Distribution$report$(labels, $gren_lang$test$Test$Runner$getDistributionReport(expectation));
	var summaryWithDistribution = function () {
		if (distributionReport.$ === 'Nothing') {
			return summary;
		} else {
			var distribution = distributionReport.a;
			return _Utils_update(summary, { output: summary.output + ('\n\n' + (distribution + '\n')) });
		}
	}();
	var _v0 = $gren_lang$test$Test$Runner$getFailureReason(expectation);
	if (_v0.$ === 'Nothing') {
		return _Utils_update(summaryWithDistribution, { passed: summaryWithDistribution.passed + 1 });
	} else {
		var _v1 = _v0.a;
		var given = _v1.given;
		var description = _v1.description;
		var reason = _v1.reason;
		var prefix = function () {
			if (given.$ === 'Nothing') {
				return '';
			} else {
				var g = given.a;
				return 'Given ' + (g + '\n\n');
			}
		}();
		var message = $gren_lang$test$Test$Runner$String$Format$format$(description, reason);
		var newOutput = '\n\n' + ($gren_lang$test$Test$Runner$String$outputLabels(labels) + ('\n' + (_Utils_ap(prefix, $gren_lang$test$Test$Runner$String$indentLines(message)) + '\n')));
		return _Utils_update(summaryWithDistribution, { failed: summaryWithDistribution.failed + 1, output: _Utils_ap(summaryWithDistribution.output, newOutput), passed: summaryWithDistribution.passed });
	}
};
var $gren_lang$test$Test$Runner$String$fromExpectation = F3($gren_lang$test$Test$Runner$String$fromExpectation$);
var $gren_lang$test$Test$Runner$String$toOutputHelp$ = function(runner, summary) {
	return A3($gren_lang$core$Array$foldl, $gren_lang$test$Test$Runner$String$fromExpectation(runner.labels), summary, runner.run({  }));
};
var $gren_lang$test$Test$Runner$String$toOutputHelp = F2($gren_lang$test$Test$Runner$String$toOutputHelp$);
var $gren_lang$test$Test$Runner$String$toOutput$ = function(summary, seededRunners) {
	var render = $gren_lang$core$Array$foldl($gren_lang$test$Test$Runner$String$toOutputHelp);
	switch (seededRunners.$) {
		case 'Plain':
			var runners = seededRunners.a;
			return A2(render, _Utils_update(summary, { autoFail: $gren_lang$core$Maybe$Nothing }), runners);
		case 'Only':
			var runners = seededRunners.a;
			return A2(render, _Utils_update(summary, { autoFail: $gren_lang$core$Maybe$Just('Test.only was used') }), runners);
		case 'Skipping':
			var runners = seededRunners.a;
			return A2(render, _Utils_update(summary, { autoFail: $gren_lang$core$Maybe$Just('Test.skip was used') }), runners);
		default:
			var message = seededRunners.a;
			return { autoFail: $gren_lang$core$Maybe$Nothing, failed: 0, output: message, passed: 0 };
	}
};
var $gren_lang$test$Test$Runner$String$toOutput = F2($gren_lang$test$Test$Runner$String$toOutput$);
var $gren_lang$test$Test$Runner$String$runWithOptions$ = function(runs, seed, test) {
	var seededRunners = $gren_lang$test$Test$Runner$fromTest$(runs, seed, test);
	return $gren_lang$test$Test$Runner$String$toOutput$({ autoFail: $gren_lang$core$Maybe$Just('no tests were run'), failed: 0, output: '', passed: 0 }, seededRunners);
};
var $gren_lang$test$Test$Runner$String$runWithOptions = F3($gren_lang$test$Test$Runner$String$runWithOptions$);
var $blaix$gren_effectful_tests_node$Test$Runner$Log$Green = { $: 'Green' };
var $blaix$gren_effectful_tests_node$Test$Runner$Log$Red = { $: 'Red' };
var $blaix$gren_effectful_tests_node$Test$Runner$Log$NoColor = { $: 'NoColor' };
var $blaix$gren_effectful_tests_node$Test$Runner$Log$colorCode = function(color) {
	switch (color.$) {
		case 'NoColor':
			return '39';
		case 'Green':
			return '32';
		default:
			return '31';
	}
};
var $blaix$gren_effectful_tests_node$Test$Runner$Log$setColor = function(color) {
	return A2($gren_lang$core$String$join, '', [ '\u001B[', $blaix$gren_effectful_tests_node$Test$Runner$Log$colorCode(color), 'm' ]);
};
var $blaix$gren_effectful_tests_node$Test$Runner$Log$colorize$ = function(colorDepth, color, string) {
	return (colorDepth > 1) ? A2($gren_lang$core$String$join, '', [ $blaix$gren_effectful_tests_node$Test$Runner$Log$setColor(color), string, $blaix$gren_effectful_tests_node$Test$Runner$Log$setColor($blaix$gren_effectful_tests_node$Test$Runner$Log$NoColor) ]) : string;
};
var $blaix$gren_effectful_tests_node$Test$Runner$Log$colorize = F3($blaix$gren_effectful_tests_node$Test$Runner$Log$colorize$);
var $blaix$gren_effectful_tests_node$Test$Runner$Log$summarize$ = function(_v0, colorDepth) {
	var output = _v0.output;
	var passed = _v0.passed;
	var failed = _v0.failed;
	var autoFail = _v0.autoFail;
	var headline = function () {
		if (failed > 0) {
			return $blaix$gren_effectful_tests_node$Test$Runner$Log$colorize$(colorDepth, $blaix$gren_effectful_tests_node$Test$Runner$Log$Red, 'TEST RUN FAILED');
		} else {
			if (autoFail.$ === 'Nothing') {
				return $blaix$gren_effectful_tests_node$Test$Runner$Log$colorize$(colorDepth, $blaix$gren_effectful_tests_node$Test$Runner$Log$Green, 'TEST RUN PASSED');
			} else {
				var reason = autoFail.a;
				return $blaix$gren_effectful_tests_node$Test$Runner$Log$colorize$(colorDepth, $blaix$gren_effectful_tests_node$Test$Runner$Log$Red, 'TEST RUN FAILED because ' + reason);
			}
		}
	}();
	return A2($gren_lang$core$String$join, '\n', [ output, headline + '\n', 'Passed: ' + $gren_lang$core$String$fromInt(passed), 'Failed: ' + $gren_lang$core$String$fromInt(failed) ]);
};
var $blaix$gren_effectful_tests_node$Test$Runner$Log$summarize = F2($blaix$gren_effectful_tests_node$Test$Runner$Log$summarize$);


// BYTES

var _Bytes_empty = new DataView(new ArrayBuffer(0));

function _Bytes_length(bytes) {
  return bytes.byteLength;
}

var _Bytes_getHostEndianness = F2(function (le, be) {
  return _Scheduler_binding(function (callback) {
    callback(
      _Scheduler_succeed(
        new Uint8Array(new Uint32Array([1]))[0] === 1 ? le : be,
      ),
    );
  });
});

function _Bytes_fromString(str) {
  var encoder = new TextEncoder();
  var uint8s = encoder.encode(str);
  return new DataView(uint8s.buffer);
}

function _Bytes_toString(bytes) {
  var decoder = new TextDecoder("utf-8", { fatal: true });

  try {
    return $gren_lang$core$Maybe$Just(decoder.decode(bytes));
  } catch (e) {
    return $gren_lang$core$Maybe$Nothing;
  }
}

function _Bytes_flatten(arrayOfBytes) {
  var requiredSize = 0;
  for (var i = 0; i < arrayOfBytes.length; i++) {
    requiredSize += arrayOfBytes[i].byteLength;
  }

  var offset = 0;
  var result = new Uint8Array(requiredSize);

  for (var i = 0; i < arrayOfBytes.length; i++) {
    var currentBytes = new Uint8Array(arrayOfBytes[i].buffer);
    var currentByteLength = arrayOfBytes[i].byteLength;

    for (var j = 0; j < currentByteLength; j++) {
      result[offset] = currentBytes[j];
      offset++;
    }
  }

  return new DataView(result.buffer);
}

// ENCODERS

function _Bytes_encode(encoder) {
  var mutableBytes = new DataView(new ArrayBuffer($gren_lang$core$Bytes$Encode$getLength(encoder)));
  A3($gren_lang$core$Bytes$Encode$write, encoder, mutableBytes, 0);
  return mutableBytes;
}

// SIGNED INTEGERS

var _Bytes_write_i8 = F3(function (mb, i, n) {
  mb.setInt8(i, n);
  return i + 1;
});
var _Bytes_write_i16 = F4(function (mb, i, n, isLE) {
  mb.setInt16(i, n, isLE);
  return i + 2;
});
var _Bytes_write_i32 = F4(function (mb, i, n, isLE) {
  mb.setInt32(i, n, isLE);
  return i + 4;
});

// UNSIGNED INTEGERS

var _Bytes_write_u8 = F3(function (mb, i, n) {
  mb.setUint8(i, n);
  return i + 1;
});
var _Bytes_write_u16 = F4(function (mb, i, n, isLE) {
  mb.setUint16(i, n, isLE);
  return i + 2;
});
var _Bytes_write_u32 = F4(function (mb, i, n, isLE) {
  mb.setUint32(i, n, isLE);
  return i + 4;
});

// FLOATS

var _Bytes_write_f32 = F4(function (mb, i, n, isLE) {
  mb.setFloat32(i, n, isLE);
  return i + 4;
});
var _Bytes_write_f64 = F4(function (mb, i, n, isLE) {
  mb.setFloat64(i, n, isLE);
  return i + 8;
});

// BYTES

var _Bytes_write_bytes = F3(function (mb, offset, bytes) {
  for (var i = 0, len = bytes.byteLength, limit = len - 4; i <= limit; i += 4) {
    mb.setUint32(offset + i, bytes.getUint32(i));
  }
  for (; i < len; i++) {
    mb.setUint8(offset + i, bytes.getUint8(i));
  }
  return offset + len;
});

// DECODER

var _Bytes_decode = F2(function (decoder, bytes) {
  try {
    return $gren_lang$core$Maybe$Just(A2(decoder, bytes, 0).value);
  } catch (e) {
    if (e instanceof RangeError) {
      return $gren_lang$core$Maybe$Nothing;
    } else {
      throw e;
    }
  }
});

var _Bytes_read_i8 = F2(function (bytes, offset) {
  return { offset: offset + 1, value: bytes.getInt8(offset) };
});
var _Bytes_read_i16 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 2, value: bytes.getInt16(offset, isLE) };
});
var _Bytes_read_i32 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 4, value: bytes.getInt32(offset, isLE) };
});
var _Bytes_read_u8 = F2(function (bytes, offset) {
  return { offset: offset + 1, value: bytes.getUint8(offset) };
});
var _Bytes_read_u16 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 2, value: bytes.getUint16(offset, isLE) };
});
var _Bytes_read_u32 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 4, value: bytes.getUint32(offset, isLE) };
});
var _Bytes_read_f32 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 4, value: bytes.getFloat32(offset, isLE) };
});
var _Bytes_read_f64 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 8, value: bytes.getFloat64(offset, isLE) };
});

var _Bytes_read_bytes = F3(function (len, bytes, offset) {
  return {
    offset: offset + len,
    value: new DataView(bytes.buffer, bytes.byteOffset + offset, len),
  };
});

var _Bytes_decodeFailure = F2(function () {
  throw 0;
});
var $gren_lang$core$Bytes$Encode$getLength = function(builder) {
	switch (builder.$) {
		case 'I8':
			return 1;
		case 'I16':
			return 2;
		case 'I32':
			return 4;
		case 'U8':
			return 1;
		case 'U16':
			return 2;
		case 'U32':
			return 4;
		case 'F32':
			return 4;
		case 'F64':
			return 8;
		case 'Seq':
			var w = builder.a.width;
			return w;
		default:
			var bs = builder.a;
			return _Bytes_length(bs);
	}
};
var $gren_lang$core$Bytes$LE = { $: 'LE' };
var $gren_lang$core$Bytes$Encode$write$ = function(builder, mb, offset) {
	switch (builder.$) {
		case 'I8':
			var n = builder.a;
			return A3(_Bytes_write_i8, mb, offset, n);
		case 'I16':
			var _v1 = builder.a;
			var e = _v1.endian;
			var n = _v1.number;
			return A4(_Bytes_write_i16, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'I32':
			var _v2 = builder.a;
			var e = _v2.endian;
			var n = _v2.number;
			return A4(_Bytes_write_i32, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'U8':
			var n = builder.a;
			return A3(_Bytes_write_u8, mb, offset, n);
		case 'U16':
			var _v3 = builder.a;
			var e = _v3.endian;
			var n = _v3.number;
			return A4(_Bytes_write_u16, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'U32':
			var _v4 = builder.a;
			var e = _v4.endian;
			var n = _v4.number;
			return A4(_Bytes_write_u32, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'F32':
			var _v5 = builder.a;
			var e = _v5.endian;
			var n = _v5.number;
			return A4(_Bytes_write_f32, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'F64':
			var _v6 = builder.a;
			var e = _v6.endian;
			var n = _v6.number;
			return A4(_Bytes_write_f64, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'Seq':
			var bs = builder.a.items;
			return $gren_lang$core$Bytes$Encode$writeSequence$(bs, mb, offset);
		default:
			var bs = builder.a;
			return A3(_Bytes_write_bytes, mb, offset, bs);
	}
};
var $gren_lang$core$Bytes$Encode$write = F3($gren_lang$core$Bytes$Encode$write$);
var $gren_lang$core$Bytes$Encode$writeSequence$ = function(builders, mb, offset) {
	return A3($gren_lang$core$Array$foldl, F2(function(builder, currentOffset) {
				return $gren_lang$core$Bytes$Encode$write$(builder, mb, currentOffset);
			}), offset, builders);
};
var $gren_lang$core$Bytes$Encode$writeSequence = F3($gren_lang$core$Bytes$Encode$writeSequence$);
var $gren_lang$core$Bytes$fromString = _Bytes_fromString;


var _Stream_read = function (stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    const reader = stream.getReader();
    reader
      .read()
      .then(({ done, value }) => {
        reader.releaseLock();

        if (done) {
          return callback(_Scheduler_fail($gren_lang$core$Stream$Closed));
        }

        if (value instanceof Uint8Array) {
          value = new DataView(
            value.buffer,
            value.byteOffset,
            value.byteLength,
          );
        }

        callback(_Scheduler_succeed(value));
      })
      .catch((err) => {
        reader.releaseLock();
        callback(
          _Scheduler_fail(
            $gren_lang$core$Stream$Cancelled(typeof err === "string" ? err : ""),
          ),
        );
      });
  });
};

var _Stream_write = F2(function (value, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    if (value instanceof DataView) {
      value = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
    }

    const writer = stream.getWriter();
    writer.ready
      .then(() => {
        const writePromise = writer.write(value);
        writer.releaseLock();
        return writePromise;
      })
      .then(() => {
        callback(_Scheduler_succeed(stream));
      })
      .catch((err) => {
        callback(
          _Scheduler_fail(
            $gren_lang$core$Stream$Cancelled(typeof err === "string" ? err : ""),
          ),
        );
      });
  });
});

var _Stream_enqueue = F2(function (value, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    if (value instanceof DataView) {
      value = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
    }

    const writer = stream.getWriter();
    writer.ready.then(() => {
      writer.write(value);
      writer.releaseLock();

      callback(_Scheduler_succeed(stream));
    });
  });
});

var _Stream_cancelReadable = F2(function (reason, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    stream.cancel(reason).then(() => {
      callback(_Scheduler_succeed({}));
    });
  });
});

var _Stream_cancelWritable = F2(function (reason, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    stream.abort(reason).then(() => {
      callback(_Scheduler_succeed({}));
    });
  });
});

var _Stream_closeWritable = function (stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    const writer = stream.getWriter();
    writer.close();
    writer.releaseLock();

    callback(_Scheduler_succeed({}));
  });
};

var _Stream_pipeThrough = F2(function (transformer, readable) {
  return _Scheduler_binding(function (callback) {
    if (readable.locked || transformer.writable.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    const transformedReader = readable.pipeThrough(transformer);
    return callback(_Scheduler_succeed(transformedReader));
  });
});

var _Stream_pipeTo = F2(function (writable, readable) {
  return _Scheduler_binding(function (callback) {
    if (readable.locked || writable.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    readable
      .pipeTo(writable)
      .then(() => {
        callback(_Scheduler_succeed({}));
      })
      .catch((err) => {
        callback(
          _Scheduler_fail(
            $gren_lang$core$Stream$Cancelled(typeof err === "string" ? err : ""),
          ),
        );
      });
  });
});

var _Stream_identityTransformation = F2(function (readCapacity, writeCapacity) {
  return _Scheduler_binding(function (callback) {
    const transformStream = new TransformStream(
      {},
      new CountQueuingStrategy({ highWaterMark: writeCapacity }),
      new CountQueuingStrategy({ highWaterMark: readCapacity }),
    );

    return callback(_Scheduler_succeed(transformStream));
  });
});

var _Stream_customTransformation = F4(
  function (toAction, initState, readCapacity, writeCapacity) {
    return _Scheduler_binding(function (callback) {
      const transformStream = new TransformStream(
        {
          start() {
            this.state = initState;
          },
          transform(chunk, controller) {
            if (chunk instanceof Uint8Array) {
              chunk = new DataView(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            }

            const action = A2(toAction, this.state, chunk);
            switch (action.ctor) {
              case "UpdateState":
                this.state = action.state;
                break;
              case "Send":
                this.state = action.state;
                for (let value of action.send) {
                  if (value instanceof DataView) {
                    value = new Uint8Array(
                      value.buffer,
                      value.byteOffset,
                      value.byteLength,
                    );
                  }

                  controller.enqueue(value);
                }
                break;
              case "Close":
                for (let value of action.send) {
                  if (value instanceof DataView) {
                    value = new Uint8Array(
                      value.buffer,
                      value.byteOffset,
                      value.byteLength,
                    );
                  }

                  controller.enqueue(value);
                }
                controller.terminate();
                break;
              case "Cancel":
                controller.error(action.cancelReason);
                break;
            }
          },
        },
        new CountQueuingStrategy({ highWaterMark: writeCapacity }),
        new CountQueuingStrategy({ highWaterMark: readCapacity }),
      );

      return callback(_Scheduler_succeed(transformStream));
    });
  },
);

var _Stream_readable = function (transformStream) {
  return transformStream.readable;
};

var _Stream_writable = function (transformStream) {
  return transformStream.writable;
};

var _Stream_textEncoder = _Scheduler_binding(function (callback) {
  return callback(_Scheduler_succeed(new TextEncoderStream()));
});

var _Stream_textDecoder = _Scheduler_binding(function (callback) {
  return callback(_Scheduler_succeed(new TextDecoderStream()));
});

var _Stream_compressor = function (algo) {
  return _Scheduler_binding(function (callback) {
    return callback(_Scheduler_succeed(new CompressionStream(algo)));
  });
};

var _Stream_decompressor = function (algo) {
  return _Scheduler_binding(function (callback) {
    return callback(_Scheduler_succeed(new DecompressionStream(algo)));
  });
};
var $gren_lang$core$Stream$Cancelled = function (a) {
	return { $: 'Cancelled', a: a };
};
var $gren_lang$core$Stream$Closed = { $: 'Closed' };
var $gren_lang$core$Stream$Locked = { $: 'Locked' };
var $gren_lang$core$Stream$write = _Stream_write;
var $gren_lang$core$Stream$writeLineAsBytes$ = function(str, stream) {
	return A2($gren_lang$core$Stream$write, $gren_lang$core$Bytes$fromString(str + '\n'), stream);
};
var $gren_lang$core$Stream$writeLineAsBytes = F2($gren_lang$core$Stream$writeLineAsBytes$);
var $blaix$gren_effectful_tests_node$Test$Runner$Log$run = function(_v0) {
	var passStream = _v0.passStream;
	var failStream = _v0.failStream;
	var colorDepth = _v0.colorDepth;
	var runs = _v0.runs;
	var seed = _v0.seed;
	var test = _v0.test;
	var summary = $gren_lang$test$Test$Runner$String$runWithOptions$(runs, seed, test);
	var output = $blaix$gren_effectful_tests_node$Test$Runner$Log$summarize$(summary, colorDepth);
	var _v1 = ((summary.failed > 0) || (!_Utils_eq(summary.autoFail, $gren_lang$core$Maybe$Nothing))) ? { exitCode: 1, stream: failStream } : { exitCode: 0, stream: passStream };
	var stream = _v1.stream;
	var exitCode = _v1.exitCode;
	return A2($gren_lang$core$Task$onError, function(_v3) {
			return $gren_lang$node$Node$exitWithCode(1);
		}, A2($gren_lang$core$Task$andThen, function(_v2) {
				return $gren_lang$node$Node$exitWithCode(exitCode);
			}, $gren_lang$core$Stream$writeLineAsBytes$(output, stream)));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$runWithOptions$ = function(env, options, test_) {
	return $gren_lang$node$Init$await$($gren_lang$node$Terminal$initialize, function(termConfig) {
			return $gren_lang$node$Init$awaitTask$(test_, function(t) {
					return $gren_lang$node$Node$endSimpleProgram($blaix$gren_effectful_tests_node$Test$Runner$Log$run({ colorDepth: $blaix$gren_effectful_tests_node$Test$Runner$Effectful$getColorDepth(termConfig), failStream: env.stderr, passStream: env.stdout, runs: options.runs, seed: options.seed, test: $blaix$gren_effectful_tests_node$Test$Runner$Effectful$unwrap(t) }));
				});
		});
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$runWithOptions = F3($blaix$gren_effectful_tests_node$Test$Runner$Effectful$runWithOptions$);
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$run$ = function(env, t) {
	return $gren_lang$node$Init$awaitTask$($gren_lang$core$Time$now, function(time) {
			var options = { runs: 100, seed: $gren_lang$core$Random$initialSeed($gren_lang$core$Time$posixToMillis(time)) };
			return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$runWithOptions$(env, options, t);
		});
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$run = F2($blaix$gren_effectful_tests_node$Test$Runner$Effectful$run$);
var $gren_lang$core$Json$Decode$succeed = _Json_succeed;
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$NotReady = function (a) {
	return { $: 'NotReady', a: a };
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$map$ = function(fn, internalTest) {
	if (internalTest.$ === 'NotReady') {
		var a = internalTest.a;
		return fn(a);
	} else {
		var t = internalTest.a;
		return $gren_lang$core$Task$succeed($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready(t));
	}
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$map = F2($blaix$gren_effectful_tests_node$Test$Runner$Effectful$map$);
var $gren_lang$core$Array$singleton = function(a) {
	return [ a ];
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrapDescription$ = function(description, internalTest) {
	return $gren_lang$core$Task$succeed($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready($gren_lang$test$Test$describe$(description, $gren_lang$core$Array$singleton($blaix$gren_effectful_tests_node$Test$Runner$Effectful$unwrap(internalTest)))));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrapDescription = F2($blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrapDescription$);
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$ = function(task, description, callback) {
	return A2($gren_lang$core$Task$andThen, $blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrapDescription(description), A2($gren_lang$core$Task$andThen, $blaix$gren_effectful_tests_node$Test$Runner$Effectful$map(callback), A2($gren_lang$core$Task$onError, function(e) {
					return $gren_lang$core$Task$succeed($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready($gren_lang$test$Test$test$('Task failed with:', function(_v0) {
									return $gren_lang$test$Expect$fail($gren_lang$core$Debug$toString(e));
								})));
				}, $gren_lang$core$Task$map$($blaix$gren_effectful_tests_node$Test$Runner$Effectful$NotReady, task))));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await = F3($blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$);


var _Crypto_impl = (function () {
  if (typeof window === "undefined") {
    return require("crypto");
  }
  return window.crypto;
})();

// Utils

var _Crypto_hashFromString = function (hash) {
  switch (hash) {
    case "SHA-256":
      return $gren_lang$core$Crypto$Sha256;
    case "SHA-384":
      return $gren_lang$core$Crypto$Sha384;
    case "SHA-512":
      return $gren_lang$core$Crypto$Sha512;
  }
};

var _Crypto_extractableFromBool = function (extractable) {
  if (extractable) {
    return $gren_lang$core$Crypto$CanBeExtracted;
  } else {
    return $gren_lang$core$Crypto$CannotBeExtracted;
  }
};

// Key Construction

var _Crypto_constructRsaKey = function (key) {
  var rsaKeyData = {
    modulusLength: key.algorithm.modulusLength,
    publicExponent: key.algorithm.publicExponent,
    hash: _Crypto_hashFromString(key.algorithm.hash.name),
    extractable: _Crypto_extractableFromBool(key.extractable),
  };
  return A2($gren_lang$core$Crypto$Key, key, rsaKeyData);
};

var _Crypto_constructHmacKey = function (key) {
  var hmacKeyData = {
    hash: _Crypto_hashFromString(key.algorithm.hash.name),
    extractable: _Crypto_extractableFromBool(key.extractable),
  };
  if (key.algorithm.length) {
    hmacKeyData.length = $gren_lang$core$Maybe$Just(key.algorithm.length);
  } else {
    hmacKeyData.length = $gren_lang$core$Maybe$Nothing;
  }
  return A2($gren_lang$core$Crypto$Key, key, hmacKeyData);
};

var _Crypto_constructAesKey = function (key) {
  var aesKeyData = {
    extractable: _Crypto_extractableFromBool(key.extractable),
  };
  switch (key.algorithm.length) {
    case 128:
      aesKeyData.length = $gren_lang$core$Crypto$AesLength128;
    case 192:
      aesKeyData.length = $gren_lang$core$Crypto$AesLength192;
    case 256:
      aesKeyData.length = $gren_lang$core$Crypto$AesLength256;
  }
  return A2($gren_lang$core$Crypto$Key, key, aesKeyData);
};

var _Crypto_constructEcKey = function (key) {
  var ecKeyData = {
    extractable: _Crypto_extractableFromBool(key.extractable),
  };
  switch (key.algorithm.namedCurve) {
    case "P-256":
      ecKeyData.namedCurve = $gren_lang$core$Crypto$P256;
    case "P-384":
      ecKeyData.namedCurve = $gren_lang$core$Crypto$P384;
    case "P-521":
      ecKeyData.namedCurve = $gren_lang$core$Crypto$P521;
  }
  return A2($gren_lang$core$Crypto$Key, key, ecKeyData);
};

// Random

var _Crypto_randomUUID = _Scheduler_binding(function (callback) {
  var randomUUID = _Crypto_impl.randomUUID();
  return callback(_Scheduler_succeed(randomUUID));
});

var _Crypto_getRandomValues = F2(function (arrayLength, valueType) {
  return _Scheduler_binding(function (callback) {
    var array;
    switch (valueType) {
      case "int8":
        array = new Int8Array(arrayLength);
        break;
      case "uint8":
        array = new Uint8Array(arrayLength);
        break;
      case "int16":
        array = new Int16Array(arrayLength);
        break;
      case "uint16":
        array = new Uint16Array(arrayLength);
        break;
      case "int32":
        array = new Int32Array(arrayLength);
        break;
      case "uint32":
        array = new Uint32Array(arrayLength);
        break;
      default:
        array = new Int8Array(0);
        break;
    }
    var randomValues = _Crypto_impl.getRandomValues(array);
    return callback(_Scheduler_succeed(new DataView(randomValues.buffer)));
  });
});

// Context

var _Crypto_getContext = _Scheduler_binding(function (callback) {
  if (_Crypto_impl.subtle) {
    return callback(_Scheduler_succeed($gren_lang$core$Crypto$SecureContext));
  }
  return callback(_Scheduler_fail({}));
});

// Generate keys

var _Crypto_generateRsaKey = F6(
  function (
    name,
    modulusLength,
    publicExponent,
    hash,
    extractable,
    permissions,
  ) {
    return _Scheduler_binding(function (callback) {
      var algorithm = {
        name: name,
        modulusLength: modulusLength,
        publicExponent: new Uint8Array(publicExponent),
        hash: hash,
      };
      _Crypto_impl.subtle
        .generateKey(algorithm, extractable, permissions)
        .then(function (key) {
          return callback(
            _Scheduler_succeed({
              publicKey: $gren_lang$core$Crypto$PublicKey(
                _Crypto_constructRsaKey(key.publicKey),
              ),
              privateKey: $gren_lang$core$Crypto$PrivateKey(
                _Crypto_constructRsaKey(key.privateKey),
              ),
            }),
          );
        })
        .catch(function (err) {
          throw "There was an unforseen error that occured when attempting to generate an RSA key. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
        });
    });
  },
);

var _Crypto_generateAesKey = F4(
  function (name, length, extractable, permissions) {
    return _Scheduler_binding(function (callback) {
      var algorithm = {
        name: name,
        length: length,
      };
      _Crypto_impl.subtle
        .generateKey(algorithm, extractable, permissions)
        .then(function (key) {
          return callback(_Scheduler_succeed(_Crypto_constructAesKey(key)));
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$AesCtrEncryptionError));
        });
    });
  },
);

var _Crypto_generateEcKey = F4(
  function (name, namedCurve, extractable, permissions) {
    return _Scheduler_binding(function (callback) {
      var algorithm = {
        name: name,
        namedCurve: namedCurve,
      };
      _Crypto_impl.subtle
        .generateKey(algorithm, extractable, permissions)
        .then(function (key) {
          return callback(
            _Scheduler_succeed({
              publicKey: $gren_lang$core$Crypto$PublicKey(
                _Crypto_constructEcKey(key.publicKey),
              ),
              privateKey: $gren_lang$core$Crypto$PrivateKey(
                _Crypto_constructEcKey(key.privateKey),
              ),
            }),
          );
        })
        .catch(function (err) {
          throw "There was an unforseen error that occured when attempting to generate an EC key. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
        });
    });
  },
);

var _Crypto_generateHmacKey = F5(
  function (name, hash, length, extractable, permissions) {
    return _Scheduler_binding(function (callback) {
      var algorithm;
      if (length == "") {
        algorithm = {
          name: name,
          hash: hash,
        };
      } else {
        algorithm = {
          name: name,
          hash: hash,
          length: length,
        };
      }
      _Crypto_impl.subtle
        .generateKey(algorithm, extractable, permissions)
        .then(function (key) {
          return callback(_Scheduler_succeed(_Crypto_constructHmacKey(key)));
        })
        .catch(function (err) {
          throw "There was an unforseen error that occured when attempting to generate an HMAC key. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
        });
    });
  },
);

// Exprort key

var _Crypto_exportKey = F2(function (format, key) {
  return _Scheduler_binding(function (callback) {
    _Crypto_impl.subtle
      .exportKey(format, key)
      .then(function (res) {
        switch (format) {
          case "jwk":
            return callback(_Scheduler_succeed(res));

          default:
            return callback(_Scheduler_succeed(new DataView(res)));
        }
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when exporting a key. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

// Import keys

var _Crypto_importRsaKey = F7(
  function (wrapper, format, keyData, algorithm, hash, extractable, keyUsages) {
    return _Scheduler_binding(function (callback) {
      _Crypto_impl.subtle
        .importKey(
          format,
          keyData,
          { name: algorithm, hash: hash },
          extractable,
          keyUsages,
        )
        .then(function (key) {
          switch (wrapper) {
            case "public":
              return callback(
                _Scheduler_succeed(
                  $gren_lang$core$Crypto$PublicKey(_Crypto_constructRsaKey(key)),
                ),
              );
            case "private":
              return callback(
                _Scheduler_succeed(
                  $gren_lang$core$Crypto$PrivateKey(_Crypto_constructRsaKey(key)),
                ),
              );
            default:
              return callback(_Scheduler_fail($gren_lang$core$Crypto$ImportRsaKeyError));
          }
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$ImportRsaKeyError));
        });
    });
  },
);

var _Crypto_importAesKey = F5(
  function (format, keyData, algorithm, extractable, keyUsages) {
    return _Scheduler_binding(function (callback) {
      _Crypto_impl.subtle
        .importKey(format, keyData, { name: algorithm }, extractable, keyUsages)
        .then(function (key) {
          return callback(_Scheduler_succeed(_Crypto_constructAesKey(key)));
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$ImportAesKeyError));
        });
    });
  },
);

var _Crypto_importEcKey = F7(
  function (
    wrapper,
    format,
    keyData,
    algorithm,
    namedCurve,
    extractable,
    keyUsages,
  ) {
    return _Scheduler_binding(function (callback) {
      _Crypto_impl.subtle
        .importKey(
          format,
          keyData,
          {
            name: algorithm,
            namedCurve: namedCurve,
          },
          extractable,
          keyUsages,
        )
        .then(function (key) {
          switch (wrapper) {
            case "public":
              return callback(
                _Scheduler_succeed(
                  $gren_lang$core$Crypto$PublicKey(_Crypto_constructEcKey(key)),
                ),
              );
            case "private":
              return callback(
                _Scheduler_succeed(
                  $gren_lang$core$Crypto$PrivateKey(_Crypto_constructEcKey(key)),
                ),
              );
            default:
              return callback(_Scheduler_fail($gren_lang$core$Crypto$ImportEcKeyError));
          }
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$ImportEcKeyError));
        });
    });
  },
);

var _Crypto_importHmacKey = F7(
  function (
    format,
    keyData,
    passedAlgorithm,
    hash,
    length,
    extractable,
    keyUsages,
  ) {
    return _Scheduler_binding(function (callback) {
      var algorithm;
      if (length == "") {
        algorithm = {
          name: passedAlgorithm,
          hash: hash,
        };
      } else {
        algorithm = {
          name: passedAlgorithm,
          hash: hash,
          length: length,
        };
      }
      _Crypto_impl.subtle
        .importKey(format, keyData, algorithm, extractable, keyUsages)
        .then(function (key) {
          return callback(_Scheduler_succeed(_Crypto_constructHmacKey(key)));
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$ImportHmacKeyError));
        });
    });
  },
);

// Encryption

var _Crypto_encryptWithRsaOaep = F3(function (label, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm;
    if (label == "") {
      algorithm = {
        name: "RSA-OAEP",
      };
    } else {
      algorithm = {
        name: "RSA-OAEP",
        label: label,
      };
    }
    _Crypto_impl.subtle
      .encrypt(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$RsaOaepEncryptionError));
      });
  });
});

var _Crypto_encryptWithAesCtr = F4(function (counter, length, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "AES-CTR",
      counter: counter,
      length: length,
    };
    _Crypto_impl.subtle
      .encrypt(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$AesCtrEncryptionError));
      });
  });
});

var _Crypto_encryptWithAesCbc = F3(function (iv, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "AES-CBC",
      iv: iv,
    };
    _Crypto_impl.subtle
      .encrypt(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$AesCbcEncryptionError));
      });
  });
});

var _Crypto_encryptWithAesGcm = F5(
  function (iv, additionalData, tagLength, key, bytes) {
    return _Scheduler_binding(function (callback) {
      var algorithm = {
        name: "AES-GCM",
        iv: iv,
      };
      if (additionalData != "") {
        algorithm.additionalData = additionalData;
      }
      if (tagLength != "") {
        algorithm.tagLength = tagLength;
      }
      _Crypto_impl.subtle
        .encrypt(algorithm, key, bytes)
        .then(function (res) {
          return callback(_Scheduler_succeed(new DataView(res)));
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$AesGcmEncryptionError));
        });
    });
  },
);

// Decrypt

var _Crypto_decryptWithRsaOaep = F3(function (label, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm;
    if (label == "") {
      algorithm = {
        name: "RSA-OAEP",
      };
    } else {
      algorithm = {
        name: "RSA-OAEP",
        label: label,
      };
    }
    _Crypto_impl.subtle
      .decrypt(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$AesCtrDecryptionError));
      });
  });
});

var _Crypto_decryptWithAesCtr = F4(function (counter, length, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "AES-CTR",
      counter: counter,
      length: length,
    };
    _Crypto_impl.subtle
      .decrypt(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$AesCtrDecryptionError));
      });
  });
});

var _Crypto_decryptWithAesCbc = F3(function (iv, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "AES-CBC",
      iv: iv,
    };
    _Crypto_impl.subtle
      .decrypt(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$AesCbcDecryptionError));
      });
  });
});

var _Crypto_decryptWithAesGcm = F5(
  function (iv, additionalData, tagLength, key, bytes) {
    return _Scheduler_binding(function (callback) {
      var algorithm = {
        name: "AES-GCM",
        iv: iv,
      };
      if (additionalData != "") {
        algorithm.additionalData = additionalData;
      }
      if (tagLength != "") {
        algorithm.tagLength = tagLength;
      }
      _Crypto_impl.subtle
        // For some reason, passing a DataView for encrypted bytes does not work on node
        // So, turned into Uint8Array to work on node _and_ browser platforms
        .decrypt(
          algorithm,
          key,
          new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength),
        )
        .then(function (res) {
          return callback(_Scheduler_succeed(new DataView(res)));
        })
        .catch(function (err) {
          return callback(_Scheduler_fail($gren_lang$core$Crypto$AesGcmDecryptionError));
        });
    });
  },
);

// Signing

var _Crypto_signWithRsaSsaPkcs1V1_5 = F2(function (key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "RSASSA-PKCS1-v1_5",
    };
    _Crypto_impl.subtle
      .sign(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$RsaSsaPkcs1V1_5SigningError));
      });
  });
});

var _Crypto_signWithRsaPss = F3(function (saltLength, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "RSA-PSS",
      saltLength: saltLength,
    };
    _Crypto_impl.subtle
      .sign(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        return callback(_Scheduler_fail($gren_lang$core$Crypto$RsaPssSigningError));
      });
  });
});

var _Crypto_signWithEcdsa = F3(function (hash, key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "ECDSA",
      hash: hash,
    };
    _Crypto_impl.subtle
      .sign(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to sign using the ECDSA algorithm. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

var _Crypto_signWithHmac = F2(function (key, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "HMAC",
    };
    _Crypto_impl.subtle
      .sign(algorithm, key, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to sign with the HMAC algorithm. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

// Verify

var _Crypto_verifyWithRsaSsaPkcs1V1_5 = F3(function (key, signature, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "RSASSA-PKCS1-v1_5",
    };
    _Crypto_impl.subtle
      .verify(algorithm, key, signature, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed());
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to verify with the RSA-SSA-PKCS v1.5 algorithm. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

var _Crypto_verifyWithRsaPss = F4(function (saltLength, key, signature, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "RSA-PSS",
      saltLength: saltLength,
    };
    _Crypto_impl.subtle
      .verify(algorithm, key, signature, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed());
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to verify with the RSA-PSS algorithm. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

var _Crypto_verifyWithEcdsa = F4(function (hash, key, signature, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "ECDSA",
      hash: hash,
    };
    _Crypto_impl.subtle
      .verify(algorithm, key, signature, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(res));
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to verify with the ECDSA algorithm. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

var _Crypto_verifyWithHmac = F3(function (key, signature, bytes) {
  return _Scheduler_binding(function (callback) {
    var algorithm = {
      name: "HMAC",
    };
    _Crypto_impl.subtle
      .verify(algorithm, key, signature, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(res));
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to verify with the HMAC algorithm. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});

// Digest

var _Crypto_digest = F2(function (algorithm, bytes) {
  return _Scheduler_binding(function (callback) {
    _Crypto_impl.subtle
      .digest(algorithm, bytes)
      .then(function (res) {
        return callback(_Scheduler_succeed(new DataView(res)));
      })
      .catch(function (err) {
        throw "There was an unforseen error that occured when attempting to digest some bytes. This shouldn't happen! Please file a ticket in the `gren-lang/core` Github repo (https://github.com/gren-lang/core)";
      });
  });
});
var $gren_lang$core$Crypto$AesCbcDecryptionError = { $: 'AesCbcDecryptionError' };
var $gren_lang$core$Crypto$AesCbcEncryptionError = { $: 'AesCbcEncryptionError' };
var $gren_lang$core$Crypto$AesCtrDecryptionError = { $: 'AesCtrDecryptionError' };
var $gren_lang$core$Crypto$AesCtrEncryptionError = { $: 'AesCtrEncryptionError' };
var $gren_lang$core$Crypto$AesGcmDecryptionError = { $: 'AesGcmDecryptionError' };
var $gren_lang$core$Crypto$AesGcmEncryptionError = { $: 'AesGcmEncryptionError' };
var $gren_lang$core$Crypto$AesLength128 = { $: 'AesLength128' };
var $gren_lang$core$Crypto$AesLength192 = { $: 'AesLength192' };
var $gren_lang$core$Crypto$AesLength256 = { $: 'AesLength256' };
var $gren_lang$core$Crypto$CanBeExtracted = { $: 'CanBeExtracted' };
var $gren_lang$core$Crypto$CannotBeExtracted = { $: 'CannotBeExtracted' };
var $gren_lang$core$Crypto$ImportAesKeyError = { $: 'ImportAesKeyError' };
var $gren_lang$core$Crypto$ImportEcKeyError = { $: 'ImportEcKeyError' };
var $gren_lang$core$Crypto$ImportHmacKeyError = { $: 'ImportHmacKeyError' };
var $gren_lang$core$Crypto$ImportRsaKeyError = { $: 'ImportRsaKeyError' };
var $gren_lang$core$Crypto$Key = function (a) {
	return { $: 'Key', a: a };
};
var $gren_lang$core$Crypto$P256 = { $: 'P256' };
var $gren_lang$core$Crypto$P384 = { $: 'P384' };
var $gren_lang$core$Crypto$P521 = { $: 'P521' };
var $gren_lang$core$Crypto$PrivateKey = function (a) {
	return { $: 'PrivateKey', a: a };
};
var $gren_lang$core$Crypto$PublicKey = function (a) {
	return { $: 'PublicKey', a: a };
};
var $gren_lang$core$Crypto$RsaOaepEncryptionError = { $: 'RsaOaepEncryptionError' };
var $gren_lang$core$Crypto$RsaPssSigningError = { $: 'RsaPssSigningError' };
var $gren_lang$core$Crypto$RsaSsaPkcs1V1_5SigningError = { $: 'RsaSsaPkcs1V1_5SigningError' };
var $gren_lang$core$Crypto$SecureContext = { $: 'SecureContext' };
var $gren_lang$core$Crypto$Sha256 = { $: 'Sha256' };
var $gren_lang$core$Crypto$Sha384 = { $: 'Sha384' };
var $gren_lang$core$Crypto$Sha512 = { $: 'Sha512' };
var $gren_lang$core$Crypto$getSecureContext = _Crypto_getContext;
var $gren_lang$core$Crypto$randomUuidV4 = function(_v0) {
	return _Crypto_randomUUID;
};
var $gren_lang$core$Process$sleep = _Process_sleep;
var $gren_lang$node$HttpClient$ExpectJson = function (a) {
	return { $: 'ExpectJson', a: a };
};
var $gren_lang$node$HttpClient$expectJson$ = function(decoder, req) {
	return { body: req.body, expect: $gren_lang$node$HttpClient$ExpectJson(decoder), headers: req.headers, method: req.method, timeout: req.timeout, url: req.url };
};
var $gren_lang$node$HttpClient$expectJson = F2($gren_lang$node$HttpClient$expectJson$);
var $gren_lang$node$HttpServer$POST = { $: 'POST' };
var $gren_lang$node$HttpClient$BodyEmpty = { $: 'BodyEmpty' };
var $gren_lang$node$HttpClient$ExpectAnything = { $: 'ExpectAnything' };
var $gren_lang$node$HttpClient$defaultTimeout = 10 * 1000;
var $gren_lang$node$HttpClient$request$ = function(method, url) {
	return { body: $gren_lang$node$HttpClient$BodyEmpty, expect: $gren_lang$node$HttpClient$ExpectAnything, headers: $gren_lang$core$Dict$empty, method: method, timeout: $gren_lang$node$HttpClient$defaultTimeout, url: url };
};
var $gren_lang$node$HttpClient$request = F2($gren_lang$node$HttpClient$request$);
var $gren_lang$node$HttpClient$post = function(url) {
	return $gren_lang$node$HttpClient$request$($gren_lang$node$HttpServer$POST, url);
};


var buffer = require("node:buffer").Buffer;

function _HttpClient_clientForProtocol(config) {
  if (config.url.startsWith("http://")) {
    return require("node:http");
  }

  return require("node:https");
}

var _HttpClient_request = function (config) {
  return _Scheduler_binding(function (callback) {
    let req = null;
    try {
      const client = _HttpClient_clientForProtocol(config);
      req = client.request(config.url, {
        method: config.method,
        headers: A3(
          $gren_lang$core$Dict$foldl,
          _HttpClient_dictToObject,
          {},
          config.headers,
        ),
        timeout: config.timeout,
      });
    } catch (e) {
      if (e.code === "ERR_INVALID_HTTP_TOKEN") {
        return callback(_Scheduler_fail($gren_lang$node$HttpClient$BadHeaders));
      } else if (e.code === "ERR_INVALID_URL") {
        return callback(_Scheduler_fail($gren_lang$node$HttpClient$BadUrl(config.url)));
      } else {
        return callback(
          _Scheduler_fail(
            $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
          ),
        );
      }
    }

    req.on("timeout", () => {
      req.destroy(_HttpClient_CustomTimeoutError);
    });

    req.on("error", (e) => {
      if (e === _HttpClient_CustomTimeoutError) {
        return callback(_Scheduler_fail($gren_lang$node$HttpClient$Timeout));
      }

      return callback(
        _Scheduler_fail(
          $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
        ),
      );
    });

    req.on("response", (res) => {
      const expectType = config.expectType;

      let rawData = null;

      if (expectType === "STRING" || expectType === "JSON") {
        res.setEncoding("utf8");

        res.on("data", (chunk) => {
          if (rawData === null) {
            rawData = chunk;
          } else {
            rawData += chunk;
          }
        });
      } else {
        res.on("data", (chunk) => {
          if (rawData === null) {
            rawData = [chunk];
          } else {
            rawData.push(chunk);
          }
        });
      }

      res.on("error", (e) => {
        return callback(
          _Scheduler_fail(
            $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
          ),
        );
      });

      res.on("end", () => {
        if (res.statusCode < 200 || res.statusCode >= 300) {
          return callback(
            _Scheduler_fail(
              $gren_lang$node$HttpClient$BadStatus(_HttpClient_formatResponse(res, rawData)),
            ),
          );
        }

        switch (expectType) {
          case "NOTHING":
            if (rawData === null) {
              return callback(
                _Scheduler_succeed(_HttpClient_formatResponse(res, {})),
              );
            } else {
              return callback(
                _Scheduler_fail(
                  $gren_lang$node$HttpClient$UnexpectedResponseBody(
                    "Received response body where I expected none.",
                  ),
                ),
              );
            }

          case "ANYTHING":
            return callback(
              _Scheduler_succeed(_HttpClient_formatResponse(res, {})),
            );

          case "STRING":
            return callback(
              _Scheduler_succeed(_HttpClient_formatResponse(res, rawData)),
            );

          case "JSON":
            const jsonResult = A2(
              $gren_lang$core$Json$Decode$decodeString,
              config.expect.a,
              rawData,
            );
            if ($gren_lang$core$Result$isOk(jsonResult)) {
              return callback(
                _Scheduler_succeed(
                  _HttpClient_formatResponse(res, jsonResult.a),
                ),
              );
            } else {
              return callback(
                _Scheduler_fail(
                  $gren_lang$node$HttpClient$UnexpectedResponseBody(
                    $gren_lang$core$Json$Decode$errorToString(jsonResult.a),
                  ),
                ),
              );
            }

          case "BYTES":
            const finalBuffer = buffer.concat(rawData);

            return callback(
              _Scheduler_succeed(
                _HttpClient_formatResponse(
                  res,
                  new DataView(
                    finalBuffer.buffer,
                    finalBuffer.byteOffset,
                    finalBuffer.byteLength,
                  ),
                ),
              ),
            );
        }
      });
    });

    const body = _HttpClient_extractRequestBody(config);

    if (body != null) {
      req.end(body);
    } else {
      req.end();
    }
  });
};

var _HttpClient_stream = F4(function (cleanup, sendToApp, request, config) {
  return _Scheduler_binding(function (callback) {
    function send(msg) {
      return _Scheduler_rawSpawn(sendToApp(msg));
    }

    let req = null;
    try {
      const client = _HttpClient_clientForProtocol(config);
      req = client.request(config.url, {
        method: config.method,
        headers: A3(
          $gren_lang$core$Dict$foldl,
          _HttpClient_dictToObject,
          {},
          config.headers,
        ),
        timeout: config.timeout,
      });
    } catch (e) {
      callback(_Scheduler_succeed(request));

      if (e.code === "ERR_INVALID_HTTP_TOKEN") {
        send($gren_lang$node$HttpClient$Error($gren_lang$node$HttpClient$BadHeaders));
      } else if (e.code === "ERR_INVALID_URL") {
        send($gren_lang$node$HttpClient$Error($gren_lang$node$HttpClient$BadUrl(config.url)));
      } else {
        send(
          $gren_lang$node$HttpClient$Error(
            $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
          ),
        );
      }

      return _Scheduler_rawSpawn(cleanup(request));
    }

    req.on("timeout", () => {
      req.destroy(_HttpClient_CustomTimeoutError);
    });

    req.on("error", (e) => {
      _Scheduler_rawSpawn(cleanup(request));

      if (e === _HttpClient_CustomTimeoutError) {
        send($gren_lang$node$HttpClient$Timeout);
      } else if (e === _HttpClient_CustomAbortError) {
        send($gren_lang$node$HttpClient$Aborted);
      } else {
        send($gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message));
      }
    });

    const body = _HttpClient_extractRequestBody(config);

    if (body == null) {
      send($gren_lang$node$HttpClient$SentChunk(request));
    } else {
      req.write(body, () => {
        send($gren_lang$node$HttpClient$SentChunk(request));
      });
    }

    return callback(
      _Scheduler_succeed({
        request: req,
        response: null,
      }),
    );
  });
});

var _HttpClient_sendChunk = F4(
  function (sendToApp, kernelRequest, request, bytes) {
    return _Scheduler_binding(function (callback) {
      if (!kernelRequest.request.writableEnded) {
        const chunk = _HttpClient_prepBytes(bytes);

        kernelRequest.request.write(chunk, () => {
          _Scheduler_rawSpawn(sendToApp($gren_lang$node$HttpClient$SentChunk(request)));
        });
      }

      return callback(_Scheduler_succeed({}));
    });
  },
);

var _HttpClient_startReceive = F4(
  function (cleanup, sendToApp, kernelRequest, request) {
    return _Scheduler_binding(function (callback) {
      if (kernelRequest.request.writableEnded) {
        return callback(_Scheduler_succeed({}));
      }
      kernelRequest.request.on("response", (res) => {
        kernelRequest.response = res;

        res.on("data", (bytes) => {
          return _Scheduler_rawSpawn(
            sendToApp(
              $gren_lang$node$HttpClient$ReceivedChunk({
                request: request,
                response: _HttpClient_formatResponse(
                  res,
                  new DataView(
                    bytes.buffer,
                    bytes.byteOffset,
                    bytes.byteLength,
                  ),
                ),
              }),
            ),
          );
        });

        res.on("error", (e) => {
          _Scheduler_rawSpawn(cleanup(request));
          _Scheduler_rawSpawn(
            sendToApp(
              $gren_lang$node$HttpClient$Error(
                $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
              ),
            ),
          );
        });

        res.on("end", () => {
          _Scheduler_rawSpawn(cleanup(request));
          _Scheduler_rawSpawn(sendToApp($gren_lang$node$HttpClient$Done));
        });
      });

      kernelRequest.request.end(() => {
        return callback(_Scheduler_succeed({}));
      });
    });
  },
);

var _HttpClient_abort = function (kernelRequest) {
  return _Scheduler_binding(function (callback) {
    if (!kernelRequest.request.writableEnded) {
      kernelRequest.request.destroy(_HttpClient_CustomAbortError);
    } else if (
      kernelRequest.response &&
      kernelRequest.response.complete === false
    ) {
      kernelRequest.response.destroy(_HttpClient_CustomAbortError);
    }

    return callback(_Scheduler_succeed({}));
  });
};

// HELPERS

var _HttpClient_dictToObject = F3(function (key, value, obj) {
  obj[key] = value;
  return obj;
});

var _HttpClient_extractRequestBody = function (config) {
  switch (config.bodyType) {
    case "EMPTY":
      return null;
    case "STRING":
      return config.body.a;
    case "BYTES":
      return _HttpClient_prepBytes(config.body.a);
  }
};

var _HttpClient_prepBytes = function (bytes) {
  return new Uint8Array(bytes.buffer);
};

var _HttpClient_CustomAbortError = new Error();

var _HttpClient_CustomTimeoutError = new Error();

var _HttpClient_formatResponse = function (res, data) {
  let headerDict = $gren_lang$core$Dict$empty;
  for (const [key, value] of Object.entries(res.headersDistinct)) {
    headerDict = A3($gren_lang$core$Dict$set, key.toLowerCase(), value, headerDict);
  }

  return {
    statusCode: res.statusCode,
    statusText: res.statusMessage,
    headers: headerDict,
    data: data,
  };
};
var $gren_lang$node$HttpClient$Aborted = { $: 'Aborted' };
var $gren_lang$node$HttpClient$BadHeaders = { $: 'BadHeaders' };
var $gren_lang$node$HttpClient$BadStatus = function (a) {
	return { $: 'BadStatus', a: a };
};
var $gren_lang$node$HttpClient$BadUrl = function (a) {
	return { $: 'BadUrl', a: a };
};
var $gren_lang$node$HttpClient$Done = { $: 'Done' };
var $gren_lang$node$HttpClient$Error = function (a) {
	return { $: 'Error', a: a };
};
var $gren_lang$node$HttpClient$ReceivedChunk = function (a) {
	return { $: 'ReceivedChunk', a: a };
};
var $gren_lang$node$HttpClient$SentChunk = function (a) {
	return { $: 'SentChunk', a: a };
};
var $gren_lang$node$HttpClient$Timeout = { $: 'Timeout' };
var $gren_lang$node$HttpClient$UnexpectedResponseBody = function (a) {
	return { $: 'UnexpectedResponseBody', a: a };
};
var $gren_lang$node$HttpClient$UnknownError = function (a) {
	return { $: 'UnknownError', a: a };
};
var $gren_lang$core$Json$Decode$decodeString = _Json_runOnString;
var $gren_lang$node$HttpClient$bodyTypeAsString = function(body) {
	switch (body.$) {
		case 'BodyEmpty':
			return 'EMPTY';
		case 'BodyString':
			return 'STRING';
		default:
			return 'BYTES';
	}
};
var $gren_lang$node$HttpClient$expectTypeAsString = function(expect) {
	switch (expect.$) {
		case 'ExpectNothing':
			return 'NOTHING';
		case 'ExpectAnything':
			return 'ANYTHING';
		case 'ExpectString':
			return 'STRING';
		case 'ExpectJson':
			return 'JSON';
		default:
			return 'BYTES';
	}
};
var $gren_lang$node$HttpServer$methodToString = function(method) {
	switch (method.$) {
		case 'GET':
			return 'GET';
		case 'HEAD':
			return 'HEAD';
		case 'POST':
			return 'POST';
		case 'PUT':
			return 'PUT';
		case 'DELETE':
			return 'DELETE';
		case 'CONNECT':
			return 'CONNECT';
		case 'TRACE':
			return 'TRACE';
		case 'PATCH':
			return 'PATCH';
		default:
			var value = method.a;
			return value;
	}
};
var $gren_lang$node$HttpClient$kernelRequestConfig$ = function(permission, config) {
	var actualUrl = function () {
		if (permission.$ === 'AnyPermission') {
			return config.url;
		} else {
			var prefix = permission.a;
			return _Utils_ap(prefix, config.url);
		}
	}();
	return { body: config.body, bodyType: $gren_lang$node$HttpClient$bodyTypeAsString(config.body), expect: config.expect, expectType: $gren_lang$node$HttpClient$expectTypeAsString(config.expect), headers: config.headers, method: $gren_lang$node$HttpServer$methodToString(config.method), timeout: config.timeout, url: actualUrl };
};
var $gren_lang$node$HttpClient$kernelRequestConfig = F2($gren_lang$node$HttpClient$kernelRequestConfig$);
var $gren_lang$node$HttpClient$send$ = function(permission, config) {
	return _HttpClient_request($gren_lang$node$HttpClient$kernelRequestConfig$(permission, config));
};
var $gren_lang$node$HttpClient$send = F2($gren_lang$node$HttpClient$send$);
var $gren_lang$url$Url$Builder$toQueryPair = function(_v0) {
	var _v1 = _v0.a;
	var key = _v1.key;
	var value = _v1.value;
	return key + ('=' + value);
};
var $gren_lang$url$Url$Builder$toQuery = function(parameters) {
	if (parameters.length === 0) {
		return '';
	} else {
		return '?' + A2($gren_lang$core$String$join, '&', A2($gren_lang$core$Array$map, $gren_lang$url$Url$Builder$toQueryPair, parameters));
	}
};
var $gren_lang$url$Url$Builder$crossOrigin$ = function(prePath, pathSegments, parameters) {
	return prePath + ('/' + (A2($gren_lang$core$String$join, '/', pathSegments) + $gren_lang$url$Url$Builder$toQuery(parameters)));
};
var $gren_lang$url$Url$Builder$crossOrigin = F3($gren_lang$url$Url$Builder$crossOrigin$);
var $joeybright$gren_turso$Turso$Db$tursoUrl = function(_v0) {
	var databaseName = _v0.databaseName;
	var organizationSlug = _v0.organizationSlug;
	var locationUrl = _v0.locationUrl;
	return $gren_lang$url$Url$Builder$crossOrigin$('https://' + (databaseName + ('-' + (organizationSlug + ('.' + (locationUrl + '.turso.io'))))), [ 'v2', 'pipeline' ], [  ]);
};
var $gren_lang$core$Json$Decode$field = _Json_decodeField;
var $joeybright$gren_turso$Turso$Db$Decode$unwrap = function(decoder_) {
	if (decoder_.$ === 'Decoder') {
		var decoder = decoder_.a;
		return decoder;
	} else {
		var _v1 = decoder_.a;
		var name = _v1.name;
		var decoder = _v1.decoder;
		return A2($gren_lang$core$Json$Decode$field, name, decoder);
	}
};
var $gren_lang$node$HttpClient$withHeader$ = function(key, value, req) {
	return _Utils_update(req, { headers: $gren_lang$core$Dict$set$($gren_lang$core$String$toLower(key), [ value ], req.headers) });
};
var $gren_lang$node$HttpClient$withHeader = F3($gren_lang$node$HttpClient$withHeader$);
var $gren_lang$node$HttpClient$BodyString = function (a) {
	return { $: 'BodyString', a: a };
};
var $gren_lang$node$HttpClient$withStringBody$ = function(mimeType, value, req) {
	return _Utils_update(req, { body: $gren_lang$node$HttpClient$BodyString(value), headers: $gren_lang$core$Dict$set$('content-type', [ mimeType ], req.headers) });
};
var $gren_lang$node$HttpClient$withStringBody = F3($gren_lang$node$HttpClient$withStringBody$);
var $gren_lang$node$HttpClient$withJsonBody$ = function(value, req) {
	return $gren_lang$node$HttpClient$withStringBody$('application/json', A2($gren_lang$core$Json$Encode$encode, 0, value), req);
};
var $gren_lang$node$HttpClient$withJsonBody = F2($gren_lang$node$HttpClient$withJsonBody$);
var $joeybright$gren_turso$Turso$Db$internalTransaction$ = function(connection, _v0, statements) {
	var prepareDecoder = _v0.prepareDecoder;
	var prepareEncoder = _v0.prepareEncoder;
	var dataDecoder = _v0.dataDecoder;
	var _v1 = connection;
	var accessToken = _v1.accessToken;
	var httpPermission = _v1.httpPermission;
	return $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$expectJson$(prepareDecoder($joeybright$gren_turso$Turso$Db$Decode$unwrap(dataDecoder)), $gren_lang$node$HttpClient$withJsonBody$(prepareEncoder(statements), $gren_lang$node$HttpClient$post($joeybright$gren_turso$Turso$Db$tursoUrl(connection))))));
};
var $joeybright$gren_turso$Turso$Db$internalTransaction = F3($joeybright$gren_turso$Turso$Db$internalTransaction$);
var $gren_lang$core$Json$Decode$fail = _Json_fail;
var $gren_lang$core$Json$Decode$andThen = _Json_andThen;
var $gren_lang$core$Json$Decode$array = _Json_decodeArray;
var $gren_lang$core$Json$Encode$array$ = function(func, entries) {
	return _Json_wrap(A3($gren_lang$core$Array$foldl, _Json_addEntry(func), _Json_emptyArray({  }), entries));
};
var $gren_lang$core$Json$Encode$array = F2($gren_lang$core$Json$Encode$array$);
var $gren_lang$core$Json$Decode$decodeValue = _Json_run;
var $gren_lang$core$Json$Encode$dict$ = function(toKey, toValue, dictionary) {
	return _Json_wrap($gren_lang$core$Dict$foldl$(F3(function(key, value, obj) {
					return A3(_Json_addField, toKey(key), toValue(value), obj);
				}), _Json_emptyObject({  }), dictionary));
};
var $gren_lang$core$Json$Encode$dict = F3($gren_lang$core$Json$Encode$dict$);
var $gren_lang$core$Json$Decode$int = _Json_decodeInt;
var $gren_lang$core$Json$Decode$map = _Json_map1;
var $gren_lang$core$Json$Decode$map2 = _Json_map2;
var $gren_lang$core$Json$Decode$map3 = _Json_map3;
var $gren_lang$core$Json$Decode$map4 = _Json_map4;
var $gren_lang$core$Json$Decode$oneOf = _Json_oneOf;
var $gren_lang$core$Json$Decode$maybe = function(decoder) {
	return $gren_lang$core$Json$Decode$oneOf([ A2($gren_lang$core$Json$Decode$map, $gren_lang$core$Maybe$Just, decoder), $gren_lang$core$Json$Decode$succeed($gren_lang$core$Maybe$Nothing) ]);
};
var $gren_lang$core$Json$Decode$string = _Json_decodeString;
var $gren_lang$core$Json$Decode$value = _Json_decodeValue;
var $joeybright$gren_turso$Turso$Db$queryDecoder$ = function(mapFunc, decoder) {
	return A4($gren_lang$core$Json$Decode$map3, F3(function(baton, baseUrl, data) {
				return { baton: baton, result: data };
			}), A2($gren_lang$core$Json$Decode$field, 'baton', $gren_lang$core$Json$Decode$maybe($gren_lang$core$Json$Decode$string)), A2($gren_lang$core$Json$Decode$field, 'base_url', $gren_lang$core$Json$Decode$maybe($gren_lang$core$Json$Decode$string)), A2($gren_lang$core$Json$Decode$field, 'results', A2($gren_lang$core$Json$Decode$andThen, mapFunc, $gren_lang$core$Json$Decode$array(A2($gren_lang$core$Json$Decode$map, function(response) {
							return { affectedRowCount: response.affectedRowCount, data: response.row, lastInsertRowId: response.lastInsertRowId };
						}, A2($gren_lang$core$Json$Decode$field, 'response', A2($gren_lang$core$Json$Decode$map, function(result) {
									return { affectedRowCount: result.affectedRowCount, lastInsertRowId: result.lastInsertRowId, result: result, row: result.row };
								}, A2($gren_lang$core$Json$Decode$field, 'result', A2($gren_lang$core$Json$Decode$andThen, function(_v0) {
											var res = _v0.res;
											var lastInsertRowId = _v0.lastInsertRowId;
											var affectedRowCount = _v0.affectedRowCount;
											var _v1 = A2($gren_lang$core$Json$Decode$decodeValue, decoder, res);
											if (_v1.$ === 'Ok') {
												var res_ = _v1.a;
												return $gren_lang$core$Json$Decode$succeed({ affectedRowCount: affectedRowCount, lastInsertRowId: lastInsertRowId, row: res_ });
											} else {
												return $gren_lang$core$Json$Decode$fail('Could not decode rows with passed decoder.');
											}
										}, A5($gren_lang$core$Json$Decode$map4, F4(function(cols, rows, affectedRowCount, lastInsertRowId) {
													var res = $gren_lang$core$Json$Encode$array$(A2($gren_lang$core$Json$Encode$dict, $gren_lang$core$Basics$identity, $gren_lang$core$Basics$identity), A2($gren_lang$core$Array$map, function(row) {
																return A3($gren_lang$core$Array$foldl, function(_v2) {
																		var key = _v2.key;
																		var value = _v2.value;
																		return A2($gren_lang$core$Dict$set, key, value);
																	}, $gren_lang$core$Dict$empty, A3($gren_lang$core$Array$map2, F2(function(col, rowItem) {
																				return { key: col, value: rowItem };
																			}), A2($gren_lang$core$Array$map, function(a) {
																				return a.name;
																			}, cols), row));
															}, A2($gren_lang$core$Array$map, $gren_lang$core$Array$map(function(b) {
																		return b.value;
																	}), rows)));
													return { affectedRowCount: affectedRowCount, lastInsertRowId: lastInsertRowId, res: res };
												}), A2($gren_lang$core$Json$Decode$field, 'cols', $gren_lang$core$Json$Decode$array(A3($gren_lang$core$Json$Decode$map2, F2(function(name, type_) {
																return { name: name, type_: type_ };
															}), A2($gren_lang$core$Json$Decode$field, 'name', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'decltype', $gren_lang$core$Json$Decode$string)))), A2($gren_lang$core$Json$Decode$field, 'rows', $gren_lang$core$Json$Decode$array($gren_lang$core$Json$Decode$array(A3($gren_lang$core$Json$Decode$map2, F2(function(type_, value) {
																	return { type_: type_, value: value };
																}), A2($gren_lang$core$Json$Decode$field, 'type', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'value', $gren_lang$core$Json$Decode$value))))), A2($gren_lang$core$Json$Decode$field, 'affected_row_count', $gren_lang$core$Json$Decode$int), A2($gren_lang$core$Json$Decode$field, 'last_insert_rowid', $gren_lang$core$Json$Decode$maybe($gren_lang$core$Json$Decode$string))))))))))));
};
var $joeybright$gren_turso$Turso$Db$queryDecoder = F2($joeybright$gren_turso$Turso$Db$queryDecoder$);
var $joeybright$gren_turso$Turso$Db$queryDecoderSingleResult = function () {
	var func = function(resultingArray) {
		var _v0 = $gren_lang$core$Array$first(resultingArray);
		if (_v0.$ === 'Just') {
			var result = _v0.a;
			return $gren_lang$core$Json$Decode$succeed(result);
		} else {
			return $gren_lang$core$Json$Decode$fail('Malformed result');
		}
	};
	return $joeybright$gren_turso$Turso$Db$queryDecoder(func);
}();
var $gren_lang$core$Json$Encode$object = function(pairs) {
	return _Json_wrap(A3($gren_lang$core$Array$foldl, F2(function(_v0, obj) {
					var key = _v0.key;
					var value = _v0.value;
					return A3(_Json_addField, key, value, obj);
				}), _Json_emptyObject({  }), pairs));
};
var $gren_lang$core$Json$Encode$string = _Json_wrap;
var $joeybright$gren_turso$Turso$Db$Encode$unwrap = function(_v0) {
	var v = _v0.a;
	return v;
};
var $joeybright$gren_turso$Turso$Db$queryArgsEncoder = function(args) {
	return $gren_lang$core$Json$Encode$array$(function(item) {
			return $gren_lang$core$Json$Encode$object([ { key: 'name', value: $gren_lang$core$Json$Encode$string(item.key) }, { key: 'value', value: $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string(item.type_) }, { key: 'value', value: item.value } ]) } ]);
		}, A2($gren_lang$core$Array$map, $joeybright$gren_turso$Turso$Db$Encode$unwrap, args));
};
var $joeybright$gren_turso$Turso$Db$statementsEncoder = function(queries) {
	return $gren_lang$core$Json$Encode$object([ { key: 'requests', value: $gren_lang$core$Json$Encode$array$(function(_v0) {
				var statement = _v0.statement;
				var parameters = _v0.parameters;
				return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('execute') }, { key: 'stmt', value: $gren_lang$core$Json$Encode$object([ { key: 'sql', value: $gren_lang$core$Json$Encode$string(statement) }, { key: 'named_args', value: $joeybright$gren_turso$Turso$Db$queryArgsEncoder(parameters) } ]) } ]);
			}, queries) } ]);
};
var $joeybright$gren_turso$Turso$Db$Decode$Decoder = function (a) {
	return { $: 'Decoder', a: a };
};
var $joeybright$gren_turso$Turso$Db$Decode$succeed = function(a) {
	return $joeybright$gren_turso$Turso$Db$Decode$Decoder($gren_lang$core$Json$Decode$succeed(a));
};
var $joeybright$gren_turso$Turso$Db$execute$ = function(connection, statement) {
	return $joeybright$gren_turso$Turso$Db$internalTransaction$(connection, { dataDecoder: $joeybright$gren_turso$Turso$Db$Decode$succeed({  }), prepareDecoder: $joeybright$gren_turso$Turso$Db$queryDecoderSingleResult, prepareEncoder: $joeybright$gren_turso$Turso$Db$statementsEncoder }, [ statement ]);
};
var $joeybright$gren_turso$Turso$Db$execute = F2($joeybright$gren_turso$Turso$Db$execute$);
var $gren_lang$test$Test$Expectation$Pass = function (a) {
	return { $: 'Pass', a: a };
};
var $gren_lang$test$Expect$pass = $gren_lang$test$Test$Expectation$Pass({ distributionReport: $gren_lang$test$Test$Distribution$NoDistribution });
var $joeybright$gren_turso$Turso$Db$Encode$Value = function (a) {
	return { $: 'Value', a: a };
};
var $joeybright$gren_turso$Turso$Db$Encode$string$ = function(field, s) {
	return $joeybright$gren_turso$Turso$Db$Encode$Value({ key: field, type_: 'text', value: $gren_lang$core$Json$Encode$string(s) });
};
var $joeybright$gren_turso$Turso$Db$Encode$string = F2($joeybright$gren_turso$Turso$Db$Encode$string$);
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrap = function(test_) {
	return $gren_lang$core$Task$succeed($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready(test_));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$ = function(description, thunk) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrap($gren_lang$test$Test$test$(description, thunk));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test = F2($blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$);
var $author$project$Tests$Turso$Db$executeTests$ = function(connection, config) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `execute` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Db$execute$(connection, { parameters: [ $joeybright$gren_turso$Turso$Db$Encode$string$('testparam', '11354314315135133151353') ], statement: 'INSERT INTO test(test) VALUES (:testparam)' }), 'Await executing a transaction with a single statement', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('It passes!', function(_v0) {
						return $gren_lang$test$Expect$pass;
					});
			}) ]);
};
var $author$project$Tests$Turso$Db$executeTests = F2($author$project$Tests$Turso$Db$executeTests$);
var $joeybright$gren_turso$Turso$Db$getAll$ = function(connection, _v0) {
	var query = _v0.query;
	var parameters = _v0.parameters;
	var decoder = _v0.decoder;
	var statement = { parameters: parameters, statement: query };
	return $joeybright$gren_turso$Turso$Db$internalTransaction$(connection, { dataDecoder: decoder, prepareDecoder: function(a) {
			return $joeybright$gren_turso$Turso$Db$queryDecoderSingleResult($gren_lang$core$Json$Decode$array(a));
		}, prepareEncoder: $joeybright$gren_turso$Turso$Db$statementsEncoder }, [ statement ]);
};
var $joeybright$gren_turso$Turso$Db$getAll = F2($joeybright$gren_turso$Turso$Db$getAll$);
var $joeybright$gren_turso$Turso$Db$Decode$FieldDecoder = function (a) {
	return { $: 'FieldDecoder', a: a };
};
var $joeybright$gren_turso$Turso$Db$Decode$map$ = function(mapper, decoder_) {
	if (decoder_.$ === 'Decoder') {
		var decoder = decoder_.a;
		return $joeybright$gren_turso$Turso$Db$Decode$Decoder(A2($gren_lang$core$Json$Decode$map, mapper, decoder));
	} else {
		var _v1 = decoder_.a;
		var name = _v1.name;
		var decoder = _v1.decoder;
		return $joeybright$gren_turso$Turso$Db$Decode$FieldDecoder({ decoder: A2($gren_lang$core$Json$Decode$map, mapper, decoder), name: name });
	}
};
var $joeybright$gren_turso$Turso$Db$Decode$map = F2($joeybright$gren_turso$Turso$Db$Decode$map$);
var $joeybright$gren_turso$Turso$Db$Decode$string = function(name) {
	return $joeybright$gren_turso$Turso$Db$Decode$FieldDecoder({ decoder: $gren_lang$core$Json$Decode$string, name: name });
};
var $author$project$Tests$Turso$Db$getAllTests$ = function(connection, config) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `getAll` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Db$getAll$(connection, { decoder: $joeybright$gren_turso$Turso$Db$Decode$map$(function(test) {
						return { test: test };
					}, $joeybright$gren_turso$Turso$Db$Decode$string('test')), parameters: [  ], query: 'SELECT * FROM test' }), 'Await selecting all rows from the test database', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('It passes!', function(_v0) {
						return $gren_lang$test$Expect$pass;
					});
			}) ]);
};
var $author$project$Tests$Turso$Db$getAllTests = F2($author$project$Tests$Turso$Db$getAllTests$);
var $gren_lang$test$Test$Runner$Failure$Equality = function (a) {
	return { $: 'Equality', a: a };
};
var $gren_lang$core$String$contains = _String_contains;
var $gren_lang$test$Test$Internal$toString = _Debug_toString;
var $gren_lang$test$Expect$testWith$ = function(makeReason, label, runTest, expected, actual) {
	return A2(runTest, actual, expected) ? $gren_lang$test$Expect$pass : $gren_lang$test$Test$Expectation$fail({ description: label, reason: A2(makeReason, $gren_lang$test$Test$Internal$toString(expected), $gren_lang$test$Test$Internal$toString(actual)) });
};
var $gren_lang$test$Expect$testWith = F5($gren_lang$test$Expect$testWith$);
var $gren_lang$core$String$toFloat = _String_toFloat;
var $gren_lang$core$String$toInt = _String_toInt;
var $gren_lang$test$Expect$equateWith$ = function(reason, comparison, b, a) {
	var isJust = function(x) {
		if (x.$ === 'Just') {
			return true;
		} else {
			return false;
		}
	};
	var isFloat = function(x) {
		return isJust($gren_lang$core$String$toFloat(x)) && (!isJust($gren_lang$core$String$toInt(x)));
	};
	var usesFloats = isFloat($gren_lang$test$Test$Internal$toString(a)) || isFloat($gren_lang$test$Test$Internal$toString(b));
	var floatError = A2($gren_lang$core$String$contains, reason, 'not') ? 'Do not use Expect.notEqual with floats. Use Expect.notWithin instead.' : 'Do not use Expect.equal with floats. Use Expect.within instead.';
	return usesFloats ? $gren_lang$test$Expect$fail(floatError) : $gren_lang$test$Expect$testWith$(F2(function(left, right) {
				return $gren_lang$test$Test$Runner$Failure$Equality({ actual: right, expected: left });
			}), reason, comparison, b, a);
};
var $gren_lang$test$Expect$equateWith = F4($gren_lang$test$Expect$equateWith$);
var $gren_lang$test$Expect$equal = A2($gren_lang$test$Expect$equateWith, 'Expect.equal', $gren_lang$core$Basics$eq);
var $joeybright$gren_turso$Turso$Db$queryDecoderMaybeOneResult = function () {
	var func = function(resultingArray) {
		var _v0 = $gren_lang$core$Array$first(resultingArray);
		if (_v0.$ === 'Just') {
			var result = _v0.a;
			var _v1 = $gren_lang$core$Array$first(result.data);
			if (_v1.$ === 'Just') {
				var value = _v1.a;
				return ($gren_lang$core$Array$length(result.data) === 1) ? $gren_lang$core$Json$Decode$succeed($gren_lang$core$Maybe$Just({ affectedRowCount: result.affectedRowCount, data: value, lastInsertRowId: result.lastInsertRowId })) : $gren_lang$core$Json$Decode$succeed($gren_lang$core$Maybe$Nothing);
			} else {
				return $gren_lang$core$Json$Decode$succeed($gren_lang$core$Maybe$Nothing);
			}
		} else {
			return $gren_lang$core$Json$Decode$succeed($gren_lang$core$Maybe$Nothing);
		}
	};
	return $joeybright$gren_turso$Turso$Db$queryDecoder(func);
}();
var $joeybright$gren_turso$Turso$Db$getMaybeOne$ = function(connection, _v0) {
	var query = _v0.query;
	var parameters = _v0.parameters;
	var decoder = _v0.decoder;
	var statement = { parameters: parameters, statement: query };
	return $joeybright$gren_turso$Turso$Db$internalTransaction$(connection, { dataDecoder: decoder, prepareDecoder: function(a) {
			return $joeybright$gren_turso$Turso$Db$queryDecoderMaybeOneResult($gren_lang$core$Json$Decode$array(a));
		}, prepareEncoder: $joeybright$gren_turso$Turso$Db$statementsEncoder }, [ statement ]);
};
var $joeybright$gren_turso$Turso$Db$getMaybeOne = F2($joeybright$gren_turso$Turso$Db$getMaybeOne$);
var $author$project$Tests$Turso$Db$getMaybeOneTests$ = function(connection, config) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `getMaybeOne` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Db$getMaybeOne$(connection, { decoder: $joeybright$gren_turso$Turso$Db$Decode$map$(function(test) {
						return { test: test };
					}, $joeybright$gren_turso$Turso$Db$Decode$string('test')), parameters: [  ], query: 'SELECT * FROM test WHERE \"test\" = \"11354314315135133151353\"' }), 'Await selecting maybe one row from the database', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The result should equal the expected value', function(_v0) {
						var _v1 = res.data.result;
						if (_v1.$ === 'Just') {
							var data = _v1.a.data;
							return A2($gren_lang$test$Expect$equal, data.test, '11354314315135133151353');
						} else {
							return $gren_lang$test$Expect$fail('The function should return the expected value');
						}
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Db$getMaybeOne$(connection, { decoder: $joeybright$gren_turso$Turso$Db$Decode$map$(function(test) {
						return { test: test };
					}, $joeybright$gren_turso$Turso$Db$Decode$string('test')), parameters: [  ], query: 'SELECT * FROM test WHERE \"test\" = \"a test value\"' }), 'Await selecting maybe one row from the database when there are more than one known result', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The result should equal the expected value', function(_v2) {
						return A2($gren_lang$test$Expect$equal, res.data.result, $gren_lang$core$Maybe$Nothing);
					});
			}) ]);
};
var $author$project$Tests$Turso$Db$getMaybeOneTests = F2($author$project$Tests$Turso$Db$getMaybeOneTests$);
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$ = function(task, description, callback) {
	return A2($gren_lang$core$Task$andThen, $blaix$gren_effectful_tests_node$Test$Runner$Effectful$wrapDescription(description), A2($gren_lang$core$Task$onError, callback, A2($gren_lang$core$Task$andThen, function(a) {
					return $gren_lang$core$Task$succeed($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready($gren_lang$test$Test$test$('Expected error, but got a non-error value:', function(_v0) {
									return $gren_lang$test$Expect$fail($gren_lang$core$Debug$toString(a));
								})));
				}, task)));
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError = F3($blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$);
var $joeybright$gren_turso$Turso$Db$queryDecoderJustOneResult = function () {
	var func = function(resultingArray) {
		var _v0 = $gren_lang$core$Array$first(resultingArray);
		if (_v0.$ === 'Just') {
			var result = _v0.a;
			var _v1 = $gren_lang$core$Array$first(result.data);
			if (_v1.$ === 'Just') {
				var value = _v1.a;
				return ($gren_lang$core$Array$length(result.data) === 1) ? $gren_lang$core$Json$Decode$succeed({ affectedRowCount: result.affectedRowCount, data: value, lastInsertRowId: result.lastInsertRowId }) : $gren_lang$core$Json$Decode$fail('');
			} else {
				return $gren_lang$core$Json$Decode$fail('');
			}
		} else {
			return $gren_lang$core$Json$Decode$fail('');
		}
	};
	return $joeybright$gren_turso$Turso$Db$queryDecoder(func);
}();
var $joeybright$gren_turso$Turso$Db$getOne$ = function(connection, _v0) {
	var query = _v0.query;
	var parameters = _v0.parameters;
	var decoder = _v0.decoder;
	var statement = { parameters: parameters, statement: query };
	return $joeybright$gren_turso$Turso$Db$internalTransaction$(connection, { dataDecoder: decoder, prepareDecoder: function(a) {
			return $joeybright$gren_turso$Turso$Db$queryDecoderJustOneResult($gren_lang$core$Json$Decode$array(a));
		}, prepareEncoder: $joeybright$gren_turso$Turso$Db$statementsEncoder }, [ statement ]);
};
var $joeybright$gren_turso$Turso$Db$getOne = F2($joeybright$gren_turso$Turso$Db$getOne$);
var $author$project$Tests$Turso$Db$getOneTests$ = function(connection, config) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `getOne` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Db$getOne$(connection, { decoder: $joeybright$gren_turso$Turso$Db$Decode$map$(function(test) {
						return { test: test };
					}, $joeybright$gren_turso$Turso$Db$Decode$string('test')), parameters: [  ], query: 'SELECT * FROM test WHERE \"test\" = \"11354314315135133151353\"' }), 'Await selecting one row from the database', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The result should equal the expected value', function(_v0) {
						return A2($gren_lang$test$Expect$equal, res.data.result.data.test, '11354314315135133151353');
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Db$getOne$(connection, { decoder: $joeybright$gren_turso$Turso$Db$Decode$map$(function(test) {
						return { test: test };
					}, $joeybright$gren_turso$Turso$Db$Decode$string('test')), parameters: [  ], query: 'SELECT * FROM test WHERE \"test\" = \"a test value\"' }), 'Await selecting one row from the database when there are more than one known result', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The function errors successfully, as expected', function(_v1) {
						return $gren_lang$test$Expect$pass;
					});
			}) ]);
};
var $author$project$Tests$Turso$Db$getOneTests = F2($author$project$Tests$Turso$Db$getOneTests$);
var $joeybright$gren_turso$Turso$Db$transaction = function(connection) {
	return A2($joeybright$gren_turso$Turso$Db$internalTransaction, connection, { dataDecoder: $joeybright$gren_turso$Turso$Db$Decode$succeed({  }), prepareDecoder: $joeybright$gren_turso$Turso$Db$queryDecoder($gren_lang$core$Json$Decode$succeed), prepareEncoder: $joeybright$gren_turso$Turso$Db$statementsEncoder });
};
var $author$project$Tests$Turso$Db$transactionTests$ = function(connection, config) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `transaction` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$(A2($joeybright$gren_turso$Turso$Db$transaction, connection, [ { parameters: [ $joeybright$gren_turso$Turso$Db$Encode$string$('test', 'a test value') ], statement: 'INSERT INTO test(test) VALUES (:test)' }, { parameters: [ $joeybright$gren_turso$Turso$Db$Encode$string$('test', 'a test value') ], statement: 'INSERT INTO test(test) VALUES (:test)' } ]), 'Await executing a transaction with multiple statements', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('It passes!', function(_v0) {
						return $gren_lang$test$Expect$pass;
					});
			}) ]);
};
var $author$project$Tests$Turso$Db$transactionTests = F2($author$project$Tests$Turso$Db$transactionTests$);
var $author$project$Tests$Turso$Db$tests$ = function(connection, config) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Db$execute$(connection, { parameters: [  ], statement: 'CREATE TABLE IF NOT EXISTS test (test TEXT)' }), 'Awaiting sending a create table statement to database', function(_v0) {
			return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Db` module', [ $author$project$Tests$Turso$Db$transactionTests$(connection, config), $author$project$Tests$Turso$Db$executeTests$(connection, config), $author$project$Tests$Turso$Db$getAllTests$(connection, config), $author$project$Tests$Turso$Db$getMaybeOneTests$(connection, config), $author$project$Tests$Turso$Db$getOneTests$(connection, config) ]);
		});
};
var $author$project$Tests$Turso$Db$tests = F2($author$project$Tests$Turso$Db$tests$);
var $gren_lang$test$Test$concat = function(tests) {
	if ($gren_lang$core$Array$isEmpty(tests)) {
		return $gren_lang$test$Test$Internal$failNow({ description: 'This `concat` has no tests in it. Let\'s give it some!', reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$EmptyArray) });
	} else {
		var _v0 = $gren_lang$test$Test$Internal$duplicatedName(tests);
		if (_v0.$ === 'Err') {
			var dups = _v0.a;
			var dupDescription = function(duped) {
				return 'A test group contains multiple tests named \'' + (duped + '\'. Do some renaming so that tests have unique names.');
			};
			return $gren_lang$test$Test$Internal$failNow({ description: A2($gren_lang$core$String$join, '\n', A2($gren_lang$core$Array$map, dupDescription, $gren_lang$core$Set$toArray(dups))), reason: $gren_lang$test$Test$Runner$Failure$Invalid($gren_lang$test$Test$Runner$Failure$DuplicatedName) });
		} else {
			return $gren_lang$test$Test$Internal$GrenTestVariant__Batch(tests);
		}
	}
};
var $blaix$gren_effectful_tests_node$Test$Runner$Effectful$concat = function(tests) {
	return $gren_lang$core$Task$map$($blaix$gren_effectful_tests_node$Test$Runner$Effectful$Ready, $gren_lang$core$Task$map$($gren_lang$test$Test$concat, $gren_lang$core$Task$sequence(A2($gren_lang$core$Array$map, $gren_lang$core$Task$map($blaix$gren_effectful_tests_node$Test$Runner$Effectful$unwrap), tests))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$CreateErrorDatabaseAlreadyExists = { $: 'CreateErrorDatabaseAlreadyExists' };
var $joeybright$gren_turso$Turso$Platform$Databases$CreateErrorGroupNotFound = { $: 'CreateErrorGroupNotFound' };
var $joeybright$gren_turso$Turso$Platform$Databases$CreateHttpError = function (a) {
	return { $: 'CreateHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Databases$createBodyEncoder = function(_v0) {
	var databaseName = _v0.databaseName;
	var group = _v0.group;
	return $gren_lang$core$Json$Encode$object([ { key: 'name', value: $gren_lang$core$Json$Encode$string(databaseName) }, { key: 'group', value: $gren_lang$core$Json$Encode$string(group) } ]);
};
var $joeybright$gren_turso$Turso$Platform$Databases$createResultDecoder = A2($gren_lang$core$Json$Decode$field, 'database', A4($gren_lang$core$Json$Decode$map3, F3(function(id, hostname, name) {
				return { databaseId: id, databaseName: name, hostname: hostname };
			}), A2($gren_lang$core$Json$Decode$field, 'DbId', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'Hostname', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'Name', $gren_lang$core$Json$Decode$string)));
var $gren_lang$core$Task$fail = _Scheduler_fail;
var $gren_lang$core$Task$mapError$ = function(convert, task) {
	return A2($gren_lang$core$Task$onError, $gren_lang$core$Basics$composeL$($gren_lang$core$Task$fail, convert), task);
};
var $gren_lang$core$Task$mapError = F2($gren_lang$core$Task$mapError$);
var $joeybright$gren_turso$Turso$Platform$Databases$create$ = function(_v0, params) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	return $gren_lang$core$Task$mapError$(function(err) {
			_v1$2:
			while (true) {
				if (err.$ === 'BadStatus') {
					switch (err.a.statusCode) {
						case 409:
							return $joeybright$gren_turso$Turso$Platform$Databases$CreateErrorDatabaseAlreadyExists;
						case 400:
							return $joeybright$gren_turso$Turso$Platform$Databases$CreateErrorGroupNotFound;
						default:
							break _v1$2;
					}
				} else {
					break _v1$2;
				}
			}
			return $joeybright$gren_turso$Turso$Platform$Databases$CreateHttpError(err);
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$createResultDecoder, $gren_lang$node$HttpClient$withJsonBody$($joeybright$gren_turso$Turso$Platform$Databases$createBodyEncoder(params), $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$post('https://api.turso.tech/v1/organizations/' + (organizationSlug + '/databases')))))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$create = F2($joeybright$gren_turso$Turso$Platform$Databases$create$);
var $author$project$Tests$Turso$Platform$Databases$createTests$ = function(connection, _v0, nextTests) {
	var nonExistantGroupName = _v0.nonExistantGroupName;
	var databaseName = _v0.databaseName;
	var groupName = _v0.groupName;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.create` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$create$(connection, { databaseName: databaseName, group: nonExistantGroupName }), 'Awaiting database creation with a group that does not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when trying to create a database in a group that does not exist', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$CreateErrorGroupNotFound);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$create$(connection, { databaseName: databaseName, group: groupName }), 'Awaiting database creation', function(databaseResult) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after creating a database', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The created name equals the name passed', function(_v2) {
							return A2($gren_lang$test$Expect$equal, databaseResult.data.databaseName, databaseName);
						}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$create$(connection, { databaseName: databaseName, group: groupName }), 'Awaiting duplicate database creation', function(err) {
							return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when trying to create a database that already exists', function(_v3) {
									return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$CreateErrorDatabaseAlreadyExists);
								});
						}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Next tests after creating a database', [ nextTests(databaseResult) ]) ]);
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$createTests = F3($author$project$Tests$Turso$Platform$Databases$createTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$FullAccess = { $: 'FullAccess' };
var $joeybright$gren_turso$Turso$Platform$Databases$createTokenBodyEncoder = function(_v0) {
	var permissions = _v0.permissions;
	return $gren_lang$core$Json$Encode$object([ { key: 'permissions', value: $gren_lang$core$Json$Encode$object([ { key: 'read_attach', value: $gren_lang$core$Json$Encode$object([ { key: 'databases', value: $gren_lang$core$Json$Encode$array$($gren_lang$core$Json$Encode$string, permissions.readAttachDatabases) } ]) } ]) } ]);
};
var $joeybright$gren_turso$Turso$Platform$Databases$createTokenResultDecoder = A2($gren_lang$core$Json$Decode$map, function(jwt) {
		return { jwt: jwt };
	}, A2($gren_lang$core$Json$Decode$field, 'jwt', $gren_lang$core$Json$Decode$string));
var $gren_lang$url$Url$Builder$QueryParameter = function (a) {
	return { $: 'QueryParameter', a: a };
};


function _Url_percentEncode(string)
{
	return encodeURIComponent(string);
}

function _Url_percentDecode(string)
{
	try
	{
		return $gren_lang$core$Maybe$Just(decodeURIComponent(string));
	}
	catch (e)
	{
		return $gren_lang$core$Maybe$Nothing;
	}
}
var $gren_lang$url$Url$percentEncode = _Url_percentEncode;
var $gren_lang$url$Url$Builder$string$ = function(key, value) {
	return $gren_lang$url$Url$Builder$QueryParameter({ key: $gren_lang$url$Url$percentEncode(key), value: $gren_lang$url$Url$percentEncode(value) });
};
var $gren_lang$url$Url$Builder$string = F2($gren_lang$url$Url$Builder$string$);
var $joeybright$gren_turso$Turso$Helpers$maybeUrlParams = A2($gren_lang$core$Array$foldl, F2(function(_v0, acc) {
			var key = _v0.key;
			var value = _v0.value;
			if (value.$ === 'Just') {
				var justValue = value.a;
				return $gren_lang$core$Array$pushLast$($gren_lang$url$Url$Builder$string$(key, justValue), acc);
			} else {
				return acc;
			}
		}), [  ]);
var $joeybright$gren_turso$Turso$Platform$Databases$tokenAuthorizationToString = function(tokenAuth) {
	if (tokenAuth.$ === 'FullAccess') {
		return 'full-access';
	} else {
		return 'read-only';
	}
};
var $joeybright$gren_turso$Turso$Platform$Databases$createToken$ = function(_v0, params) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var _v1 = params;
	var databaseName = _v1.databaseName;
	var expiration = _v1.expiration;
	var authorization = _v1.authorization;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'databases', databaseName, 'auth', 'tokens' ], $joeybright$gren_turso$Turso$Helpers$maybeUrlParams([ { key: 'expiration', value: expiration }, { key: 'authorization', value: $gren_lang$core$Maybe$map$($joeybright$gren_turso$Turso$Platform$Databases$tokenAuthorizationToString, authorization) } ]));
	return $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$createTokenResultDecoder, $gren_lang$node$HttpClient$withJsonBody$($joeybright$gren_turso$Turso$Platform$Databases$createTokenBodyEncoder(params), $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$post(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$createToken = F2($joeybright$gren_turso$Turso$Platform$Databases$createToken$);
var $author$project$Tests$Turso$Platform$Databases$createTokenTests$ = function(connection, _v0, nextTests) {
	var httpPermission = _v0.httpPermission;
	var databaseName = _v0.databaseName;
	var organizationSlug = _v0.organizationSlug;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.createToken` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$createToken$(connection, { authorization: $gren_lang$core$Maybe$Just($joeybright$gren_turso$Turso$Platform$Databases$FullAccess), databaseName: databaseName, expiration: $gren_lang$core$Maybe$Nothing, permissions: { readAttachDatabases: [  ] } }), 'Await token creation for the database', function(createdToken) {
				var databaseConnection = { accessToken: createdToken.data.jwt, databaseName: databaseName, httpPermission: httpPermission, locationUrl: 'aws-us-west-2', organizationSlug: organizationSlug };
				return nextTests(databaseConnection);
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$createTokenTests = F3($author$project$Tests$Turso$Platform$Databases$createTokenTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$DeleteErrorDatabaseNotFound = { $: 'DeleteErrorDatabaseNotFound' };
var $gren_lang$node$HttpServer$DELETE = { $: 'DELETE' };
var $joeybright$gren_turso$Turso$Platform$Databases$DeleteHttpError = function (a) {
	return { $: 'DeleteHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Databases$deleteResultDecoder = A2($gren_lang$core$Json$Decode$map, function(name) {
		return { databaseName: name };
	}, A2($gren_lang$core$Json$Decode$field, 'database', $gren_lang$core$Json$Decode$string));
var $joeybright$gren_turso$Turso$Platform$Databases$delete$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var databaseName = _v1.databaseName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'databases', databaseName ], [  ]);
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Databases$DeleteErrorDatabaseNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Databases$DeleteHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$deleteResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$request$($gren_lang$node$HttpServer$DELETE, url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$delete = F2($joeybright$gren_turso$Turso$Platform$Databases$delete$);
var $author$project$Tests$Turso$Platform$Databases$deleteTests$ = function(connection, _v0) {
	var databaseName = _v0.databaseName;
	var nonExistantDatabaseName = _v0.nonExistantDatabaseName;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.delete` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$delete$(connection, { databaseName: nonExistantDatabaseName }), 'Await removing a database that should not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when deleting a database that does not exist', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$DeleteErrorDatabaseNotFound);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$delete$(connection, { databaseName: databaseName }), 'Await removing the created test database', function(deleteDatabaseResult) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The deleted database name equals the name passed', function(_v2) {
						return A2($gren_lang$test$Expect$equal, deleteDatabaseResult.data.databaseName, databaseName);
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$deleteTests = F2($author$project$Tests$Turso$Platform$Databases$deleteTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$InvalidateTokensErrorDatabaseNotFound = { $: 'InvalidateTokensErrorDatabaseNotFound' };
var $joeybright$gren_turso$Turso$Platform$Databases$InvalidateTokensHttpError = function (a) {
	return { $: 'InvalidateTokensHttpError', a: a };
};
var $gren_lang$node$HttpClient$ExpectNothing = { $: 'ExpectNothing' };
var $gren_lang$node$HttpClient$expectNothing = function(req) {
	return { body: req.body, expect: $gren_lang$node$HttpClient$ExpectNothing, headers: req.headers, method: req.method, timeout: req.timeout, url: req.url };
};
var $joeybright$gren_turso$Turso$Platform$Databases$invalidateTokens$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var databaseName = _v1.databaseName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'databases', databaseName, 'auth', 'rotate' ], [  ]);
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Databases$InvalidateTokensErrorDatabaseNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Databases$InvalidateTokensHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectNothing($gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$post(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$invalidateTokens = F2($joeybright$gren_turso$Turso$Platform$Databases$invalidateTokens$);
var $author$project$Tests$Turso$Platform$Databases$invalidateTokensTests$ = function(connection, _v0) {
	var nonExistantDatabaseName = _v0.nonExistantDatabaseName;
	var databaseName = _v0.databaseName;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.invalidateTokens` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$invalidateTokens$(connection, { databaseName: nonExistantDatabaseName }), 'Awaiting invaliding tokens for a database that does not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when invalidating tokens for a database that does not exist', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$InvalidateTokensErrorDatabaseNotFound);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$invalidateTokens$(connection, { databaseName: databaseName }), 'Awaiting invaliding the created token', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('When invalidating tokens, the returned result is an empty record', function(_v2) {
						return A2($gren_lang$test$Expect$equal, res.data, {  });
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$invalidateTokensTests = F2($author$project$Tests$Turso$Platform$Databases$invalidateTokensTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$ListErrorGroupNotFound = { $: 'ListErrorGroupNotFound' };
var $joeybright$gren_turso$Turso$Platform$Databases$ListHttpError = function (a) {
	return { $: 'ListHttpError', a: a };
};
var $gren_lang$node$HttpServer$GET = { $: 'GET' };
var $gren_lang$node$HttpClient$get = function(url) {
	return $gren_lang$node$HttpClient$request$($gren_lang$node$HttpServer$GET, url);
};
var $gren_lang$core$Json$Decode$bool = _Json_decodeBool;
var $gren_lang$core$Json$Decode$map8 = _Json_map8;
var $joeybright$gren_turso$Turso$Platform$Databases$databaseDecoder = A4($gren_lang$core$Json$Decode$map3, F3(function(rest, deleteProtection, parent) {
			return { blockReads: rest.blockReads, blockWrites: rest.blockWrites, databaseId: rest.databaseId, deleteProtection: deleteProtection, group: rest.group, hostname: rest.hostname, name: rest.name, parent: parent, primaryRegion: rest.primaryRegion, regions: rest.regions };
		}), A9($gren_lang$core$Json$Decode$map8, F8(function(name, dbId, hostname, blockReads, blockWrites, regions, primaryRegion, group) {
				return { blockReads: blockReads, blockWrites: blockWrites, databaseId: dbId, group: group, hostname: hostname, name: name, primaryRegion: primaryRegion, regions: regions };
			}), A2($gren_lang$core$Json$Decode$field, 'Name', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'DbId', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'Hostname', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'block_reads', $gren_lang$core$Json$Decode$bool), A2($gren_lang$core$Json$Decode$field, 'block_writes', $gren_lang$core$Json$Decode$bool), A2($gren_lang$core$Json$Decode$field, 'regions', $gren_lang$core$Json$Decode$array($gren_lang$core$Json$Decode$string)), A2($gren_lang$core$Json$Decode$field, 'primaryRegion', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'group', $gren_lang$core$Json$Decode$string)), A2($gren_lang$core$Json$Decode$field, 'delete_protection', $gren_lang$core$Json$Decode$bool), A2($gren_lang$core$Json$Decode$field, 'parent', $gren_lang$core$Json$Decode$maybe(A4($gren_lang$core$Json$Decode$map3, F3(function(id, name, branchedAt) {
						return { branchedAt: branchedAt, id: id, name: name };
					}), A2($gren_lang$core$Json$Decode$field, 'id', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'name', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'branched_at', $gren_lang$core$Json$Decode$string)))));
var $joeybright$gren_turso$Turso$Platform$Databases$listDecoder = A2($gren_lang$core$Json$Decode$field, 'databases', $gren_lang$core$Json$Decode$array($joeybright$gren_turso$Turso$Platform$Databases$databaseDecoder));
var $joeybright$gren_turso$Turso$Platform$Databases$list$ = function(_v0, params) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var _v1 = params;
	var parentDbId = _v1.parentDbId;
	var groupName = _v1.groupName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'databases' ], $joeybright$gren_turso$Turso$Helpers$maybeUrlParams([ { key: 'group', value: groupName }, { key: 'parent', value: parentDbId } ]));
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Databases$ListErrorGroupNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Databases$ListHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$listDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$list = F2($joeybright$gren_turso$Turso$Platform$Databases$list$);
var $author$project$Tests$Turso$Platform$Databases$listTests$ = function(connection, _v0) {
	var nonExistantGroupName = _v0.nonExistantGroupName;
	var databaseName = _v0.databaseName;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.list` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$list$(connection, { groupName: $gren_lang$core$Maybe$Nothing, parentDbId: $gren_lang$core$Maybe$Nothing }), 'Await listing databases', function(databaseListResponse) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after getting the database list', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The newly created database is in the retrived list of databases', function(_v1) {
							return A2($gren_lang$test$Expect$equal, true, A3($gren_lang$core$Array$foldl, F2(function(_v2, acc) {
											var name = _v2.name;
											return (acc === true) ? true : (_Utils_eq(name, databaseName) ? true : false);
										}), false, databaseListResponse.data));
						}) ]);
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$list$(connection, { groupName: $gren_lang$core$Maybe$Just(nonExistantGroupName), parentDbId: $gren_lang$core$Maybe$Nothing }), 'Awaiting getting a list of databases from a group that does not exist', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when getting a list of database from a group that does not exist', function(_v3) {
						return A2($gren_lang$test$Expect$equal, res, $joeybright$gren_turso$Turso$Platform$Databases$ListErrorGroupNotFound);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$list$(connection, { groupName: $gren_lang$core$Maybe$Nothing, parentDbId: $gren_lang$core$Maybe$Just('grjeghregahgkjhrgkehgkehragrger') }), 'Awaiting getting a list of databases from a parent that does not exist', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after getting a list of database from a parent that does not exist', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned value is an empty list', function(_v4) {
							return A2($gren_lang$test$Expect$equal, res.data, [  ]);
						}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned status code is 200', function(_v5) {
							return A2($gren_lang$test$Expect$equal, res.statusCode, 200);
						}) ]);
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$list$(connection, { groupName: $gren_lang$core$Maybe$Just(nonExistantGroupName), parentDbId: $gren_lang$core$Maybe$Just('grjeghregahgkjhrgkehgkehragrger') }), 'Awaiting getting a list of databases from a parent and group that does not exist', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when getting a list of database from a parent that does not exist', function(_v6) {
						return A2($gren_lang$test$Expect$equal, res, $joeybright$gren_turso$Turso$Platform$Databases$ListErrorGroupNotFound);
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$listTests = F2($author$project$Tests$Turso$Platform$Databases$listTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$RetrieveErrorDatabaseNotFound = { $: 'RetrieveErrorDatabaseNotFound' };
var $joeybright$gren_turso$Turso$Platform$Databases$RetrieveHttpError = function (a) {
	return { $: 'RetrieveHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Databases$retrieveResultDecoder = A2($gren_lang$core$Json$Decode$field, 'database', $joeybright$gren_turso$Turso$Platform$Databases$databaseDecoder);
var $joeybright$gren_turso$Turso$Platform$Databases$retrieve$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var databaseName = _v1.databaseName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'databases', databaseName ], [  ]);
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Databases$RetrieveErrorDatabaseNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Databases$RetrieveHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$retrieveResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$retrieve = F2($joeybright$gren_turso$Turso$Platform$Databases$retrieve$);
var $author$project$Tests$Turso$Platform$Databases$retrieveTests$ = function(connection, _v0) {
	var databaseName = _v0.databaseName;
	var nonExistantDatabaseName = _v0.nonExistantDatabaseName;
	var databaseResult = _v0.databaseResult;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.retrieve` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$retrieve$(connection, { databaseName: nonExistantDatabaseName }), 'Awaiting retrieving a database that should not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after retrieving the database', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when retrieving a database that does not exist', function(_v1) {
							return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$RetrieveErrorDatabaseNotFound);
						}) ]);
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$retrieve$(connection, { databaseName: databaseName }), 'Awaiting retrieving the newly created database', function(retrievedDatabase) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after retrieving the database', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The retrieved database id matches the originally created database id', function(_v2) {
							return A2($gren_lang$test$Expect$equal, retrievedDatabase.data.databaseId, databaseResult.data.databaseId);
						}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The retrieved database name matches the generated database name', function(_v3) {
							return A2($gren_lang$test$Expect$equal, retrievedDatabase.data.name, databaseName);
						}) ]);
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$retrieveTests = F2($author$project$Tests$Turso$Platform$Databases$retrieveTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$StatsErrorDatabaseNotFound = { $: 'StatsErrorDatabaseNotFound' };
var $joeybright$gren_turso$Turso$Platform$Databases$StatsHttpError = function (a) {
	return { $: 'StatsHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Databases$statsResultDecoder = A2($gren_lang$core$Json$Decode$map, function(maybeTopQueries) {
		return { topQueries: $gren_lang$core$Maybe$withDefault$([  ], maybeTopQueries) };
	}, A2($gren_lang$core$Json$Decode$field, 'top_queries', $gren_lang$core$Json$Decode$maybe($gren_lang$core$Json$Decode$array(A4($gren_lang$core$Json$Decode$map3, F3(function(query, read, written) {
							return { query: query, rowsRead: read, rowsWritten: written };
						}), A2($gren_lang$core$Json$Decode$field, 'query', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'rows_read', $gren_lang$core$Json$Decode$int), A2($gren_lang$core$Json$Decode$field, 'rows_written', $gren_lang$core$Json$Decode$int))))));
var $joeybright$gren_turso$Turso$Platform$Databases$stats$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var databaseName = _v1.databaseName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech', [ 'v1', 'organizations', organizationSlug, 'databases', databaseName, 'stats' ], [  ]);
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Databases$StatsErrorDatabaseNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Databases$StatsHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$statsResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$stats = F2($joeybright$gren_turso$Turso$Platform$Databases$stats$);
var $author$project$Tests$Turso$Platform$Databases$statsTests$ = function(connection, _v0) {
	var nonExistantDatabaseName = _v0.nonExistantDatabaseName;
	var databaseName = _v0.databaseName;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.stats` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$stats$(connection, { databaseName: nonExistantDatabaseName }), 'Awaiting getting stats for a database that does not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when getting stats for a database that does not exist', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$StatsErrorDatabaseNotFound);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$stats$(connection, { databaseName: databaseName }), 'Awaiting getting stats for the created database', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('Fails to get stats for the created database with server error 500', function(_v2) {
						if (((err.$ === 'StatsHttpError') && (err.a.$ === 'BadStatus')) && (err.a.a.statusCode === 400)) {
							return $gren_lang$test$Expect$pass;
						} else {
							return $gren_lang$test$Expect$fail('Did not fail with the correct status code');
						}
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$statsTests = F2($author$project$Tests$Turso$Platform$Databases$statsTests$);
var $joeybright$gren_turso$Turso$Platform$Databases$UsageErrorDatabaseNotFound = { $: 'UsageErrorDatabaseNotFound' };
var $joeybright$gren_turso$Turso$Platform$Databases$UsageErrorInvalidQueryParameter = { $: 'UsageErrorInvalidQueryParameter' };
var $joeybright$gren_turso$Turso$Platform$Databases$UsageHttpError = function (a) {
	return { $: 'UsageHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Databases$usageResultsDecoder = function () {
	var statsDecoder = A5($gren_lang$core$Json$Decode$map4, F4(function(read, written, storage, synced) {
				return { bytesSynced: synced, rowsRead: read, rowsWritten: written, storageBytes: storage };
			}), A2($gren_lang$core$Json$Decode$field, 'rows_read', $gren_lang$core$Json$Decode$int), A2($gren_lang$core$Json$Decode$field, 'rows_written', $gren_lang$core$Json$Decode$int), A2($gren_lang$core$Json$Decode$field, 'storage_bytes', $gren_lang$core$Json$Decode$int), A2($gren_lang$core$Json$Decode$field, 'bytes_synced', $gren_lang$core$Json$Decode$int));
	return A2($gren_lang$core$Json$Decode$field, 'database', A4($gren_lang$core$Json$Decode$map3, F3(function(id, total, instances) {
					return { databaseId: id, instances: instances, totalUsage: total };
				}), A2($gren_lang$core$Json$Decode$field, 'uuid', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'usage', statsDecoder), A2($gren_lang$core$Json$Decode$field, 'instances', $gren_lang$core$Json$Decode$array(A3($gren_lang$core$Json$Decode$map2, F2(function(instanceId, usageValue) {
								return { databaseInstanceId: instanceId, usage: usageValue };
							}), A2($gren_lang$core$Json$Decode$field, 'uuid', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'usage', statsDecoder))))));
}();
var $joeybright$gren_turso$Turso$Platform$Databases$usage$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var databaseName = _v1.databaseName;
	var from = _v1.from;
	var to = _v1.to;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech', [ 'v1', 'organizations', organizationSlug, 'databases', databaseName, 'usage' ], $joeybright$gren_turso$Turso$Helpers$maybeUrlParams([ { key: 'from', value: from }, { key: 'to', value: to } ]));
	return $gren_lang$core$Task$mapError$(function(err) {
			_v2$2:
			while (true) {
				if (err.$ === 'BadStatus') {
					switch (err.a.statusCode) {
						case 400:
							return $joeybright$gren_turso$Turso$Platform$Databases$UsageErrorInvalidQueryParameter;
						case 404:
							return $joeybright$gren_turso$Turso$Platform$Databases$UsageErrorDatabaseNotFound;
						default:
							break _v2$2;
					}
				} else {
					break _v2$2;
				}
			}
			return $joeybright$gren_turso$Turso$Platform$Databases$UsageHttpError(err);
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Databases$usageResultsDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Databases$usage = F2($joeybright$gren_turso$Turso$Platform$Databases$usage$);
var $author$project$Tests$Turso$Platform$Databases$usageTests$ = function(connection, _v0) {
	var databaseName = _v0.databaseName;
	var nonExistantDatabaseName = _v0.nonExistantDatabaseName;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Databases.usage` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$usage$(connection, { databaseName: nonExistantDatabaseName, from: $gren_lang$core$Maybe$Nothing, to: $gren_lang$core$Maybe$Nothing }), 'Awaiting getting usage for a database that doesn\'t exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when trying to get database usage from a database that doesn\'t exist', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$UsageErrorDatabaseNotFound);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Databases$usage$(connection, { databaseName: databaseName, from: $gren_lang$core$Maybe$Nothing, to: $gren_lang$core$Maybe$Nothing }), 'Awaiting getting usage for the created database', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('Successfully retrieves usage', function(_v2) {
						return $gren_lang$test$Expect$pass;
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Databases$usage$(connection, { databaseName: databaseName, from: $gren_lang$core$Maybe$Just('invalid'), to: $gren_lang$core$Maybe$Just('another invalid string') }), 'Awaiting getting usage for the created database with incorrect parameters', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned type is expected when trying to get database usage with invalid parameters', function(_v3) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Databases$UsageErrorInvalidQueryParameter);
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$usageTests = F2($author$project$Tests$Turso$Platform$Databases$usageTests$);
var $author$project$Tests$Turso$Platform$Databases$tests$ = function(connection, _v0, nextTests) {
	var randomUuid = _v0.randomUuid;
	var group = _v0.group;
	var nonExistantGroupName = 'randomgroupnamethatshouldnotexistreallyitshouldnotpleasedontmakeagroupofthisname';
	var nonExistantDatabaseName = 'randomdatabasenamethatshouldnotreallyexist';
	var databaseName = 'gren-test-db-' + randomUuid;
	var _v1 = connection;
	var httpPermission = _v1.httpPermission;
	var accessToken = _v1.accessToken;
	var organizationSlug = _v1.organizationSlug;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Database` module', [ $author$project$Tests$Turso$Platform$Databases$createTests$(connection, { databaseName: databaseName, groupName: group, nonExistantGroupName: nonExistantGroupName }, function(databaseResult) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after creating a database', [ $author$project$Tests$Turso$Platform$Databases$usageTests$(connection, { databaseName: databaseName, nonExistantDatabaseName: nonExistantDatabaseName }), $author$project$Tests$Turso$Platform$Databases$listTests$(connection, { databaseName: databaseName, nonExistantGroupName: nonExistantGroupName }), $author$project$Tests$Turso$Platform$Databases$statsTests$(connection, { databaseName: databaseName, nonExistantDatabaseName: nonExistantDatabaseName }), $author$project$Tests$Turso$Platform$Databases$retrieveTests$(connection, { databaseName: databaseName, databaseResult: databaseResult, nonExistantDatabaseName: nonExistantDatabaseName }), $author$project$Tests$Turso$Platform$Databases$createTokenTests$(connection, { databaseName: databaseName, httpPermission: httpPermission, organizationSlug: organizationSlug }, function(databaseConnection) {
							return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after creating token to access database', [ A2(nextTests, { databaseConnection: databaseConnection, tableName: 'test' }, $blaix$gren_effectful_tests_node$Test$Runner$Effectful$concat([ $author$project$Tests$Turso$Platform$Databases$invalidateTokensTests$(connection, { databaseName: databaseName, nonExistantDatabaseName: nonExistantDatabaseName }), $author$project$Tests$Turso$Platform$Databases$deleteTests$(connection, { databaseName: databaseName, nonExistantDatabaseName: nonExistantDatabaseName }) ])) ]);
						}) ]);
			}) ]);
};
var $author$project$Tests$Turso$Platform$Databases$tests = F3($author$project$Tests$Turso$Platform$Databases$tests$);
var $gren_lang$core$Json$Decode$map6 = _Json_map6;
var $joeybright$gren_turso$Turso$Platform$Groups$groupDecoder = A7($gren_lang$core$Json$Decode$map6, F6(function(name, version, id, locations, primaryLocation, deleteProtection) {
			return { deleteProtection: deleteProtection, groupId: id, locations: locations, name: name, primaryLocation: primaryLocation, version: version };
		}), A2($gren_lang$core$Json$Decode$field, 'name', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'version', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'uuid', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'locations', $gren_lang$core$Json$Decode$array($gren_lang$core$Json$Decode$string)), A2($gren_lang$core$Json$Decode$field, 'primary', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'delete_protection', $gren_lang$core$Json$Decode$bool));
var $joeybright$gren_turso$Turso$Platform$Groups$listDecoder = A2($gren_lang$core$Json$Decode$field, 'groups', $gren_lang$core$Json$Decode$array($joeybright$gren_turso$Turso$Platform$Groups$groupDecoder));
var $joeybright$gren_turso$Turso$Platform$Groups$list = function(_v0) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'groups' ], [  ]);
	return $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Groups$listDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url))));
};
var $author$project$Tests$Turso$Platform$Groups$listTests$ = function(connection, groupName) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for `Turso.Platform.Groups.list` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Groups$list(connection), 'Awaiting listing groups', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The returned group list contains the passed group name', function(_v0) {
						return A2($gren_lang$test$Expect$equal, $gren_lang$core$Array$any$(function(_v1) {
									var name = _v1.name;
									return _Utils_eq(name, groupName);
								}, res.data), true);
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Groups$listTests = F2($author$project$Tests$Turso$Platform$Groups$listTests$);
var $joeybright$gren_turso$Turso$Platform$Groups$RetrieveConfigurationErrorGroupNotFound = { $: 'RetrieveConfigurationErrorGroupNotFound' };
var $joeybright$gren_turso$Turso$Platform$Groups$RetrieveConfigurationHttpError = function (a) {
	return { $: 'RetrieveConfigurationHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Groups$retrieveConfigurationDecoder = A2($gren_lang$core$Json$Decode$map, function(_delete) {
		return { deleteProtection: _delete };
	}, A2($gren_lang$core$Json$Decode$field, 'delete_protection', $gren_lang$core$Json$Decode$bool));
var $joeybright$gren_turso$Turso$Platform$Groups$retrieveConfiguration$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var groupName = _v1.groupName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'groups', groupName, 'configuration' ], [  ]);
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Groups$RetrieveConfigurationErrorGroupNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Groups$RetrieveConfigurationHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Groups$retrieveConfigurationDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Groups$retrieveConfiguration = F2($joeybright$gren_turso$Turso$Platform$Groups$retrieveConfiguration$);
var $author$project$Tests$Turso$Platform$Groups$retrieveConfigurationTests$ = function(connection, groupName) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Groups.retrieveConfiguration` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Groups$retrieveConfiguration$(connection, { groupName: groupName }), 'Await retrieving configuration for a group that should exist', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('Retrieving the configuration succeeds!', function(_v0) {
						return $gren_lang$test$Expect$pass;
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Groups$retrieveConfiguration$(connection, { groupName: 'agroupnamethatshouldnotexistandifitdoesthistestwillfail' }), 'Await retrieving configuration for a group that should not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The resulting error matches the expected error', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Groups$RetrieveConfigurationErrorGroupNotFound);
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Groups$retrieveConfigurationTests = F2($author$project$Tests$Turso$Platform$Groups$retrieveConfigurationTests$);
var $joeybright$gren_turso$Turso$Platform$Groups$RetrieveErrorGroupNotFound = { $: 'RetrieveErrorGroupNotFound' };
var $joeybright$gren_turso$Turso$Platform$Groups$RetrieveHttpError = function (a) {
	return { $: 'RetrieveHttpError', a: a };
};
var $joeybright$gren_turso$Turso$Platform$Groups$retrieveDecoder = A2($gren_lang$core$Json$Decode$field, 'group', $joeybright$gren_turso$Turso$Platform$Groups$groupDecoder);
var $joeybright$gren_turso$Turso$Platform$Groups$retrieve$ = function(_v0, _v1) {
	var httpPermission = _v0.httpPermission;
	var accessToken = _v0.accessToken;
	var organizationSlug = _v0.organizationSlug;
	var groupName = _v1.groupName;
	var url = $gren_lang$url$Url$Builder$crossOrigin$('https://api.turso.tech/v1', [ 'organizations', organizationSlug, 'groups', groupName ], [  ]);
	return $gren_lang$core$Task$mapError$(function(err) {
			if ((err.$ === 'BadStatus') && (err.a.statusCode === 404)) {
				return $joeybright$gren_turso$Turso$Platform$Groups$RetrieveErrorGroupNotFound;
			} else {
				return $joeybright$gren_turso$Turso$Platform$Groups$RetrieveHttpError(err);
			}
		}, $gren_lang$node$HttpClient$send$(httpPermission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Groups$retrieveDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + accessToken, $gren_lang$node$HttpClient$get(url)))));
};
var $joeybright$gren_turso$Turso$Platform$Groups$retrieve = F2($joeybright$gren_turso$Turso$Platform$Groups$retrieve$);
var $author$project$Tests$Turso$Platform$Groups$retrieveTests$ = function(connection, groupName) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for `Turso.Platform.Groups.retrieve` function', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Groups$retrieve$(connection, { groupName: groupName }), 'Await retrieving a group that should exist', function(res) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The resulting group name matches the given group name', function(_v0) {
						return A2($gren_lang$test$Expect$equal, res.data.name, groupName);
					});
			}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$awaitError$($joeybright$gren_turso$Turso$Platform$Groups$retrieve$(connection, { groupName: 'agroupnamethatshouldnotexistandifitdoesthistestwillfail' }), 'Await retrieving a group that should not exist', function(err) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The resulting error matches the expected error', function(_v1) {
						return A2($gren_lang$test$Expect$equal, err, $joeybright$gren_turso$Turso$Platform$Groups$RetrieveErrorGroupNotFound);
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Groups$retrieveTests = F2($author$project$Tests$Turso$Platform$Groups$retrieveTests$);
var $author$project$Tests$Turso$Platform$Groups$tests$ = function(tursoPlatformConnection, groupName) {
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Groups` module', [ $author$project$Tests$Turso$Platform$Groups$listTests$(tursoPlatformConnection, groupName), $author$project$Tests$Turso$Platform$Groups$retrieveTests$(tursoPlatformConnection, groupName), $author$project$Tests$Turso$Platform$Groups$retrieveConfigurationTests$(tursoPlatformConnection, groupName) ]);
};
var $author$project$Tests$Turso$Platform$Groups$tests = F2($author$project$Tests$Turso$Platform$Groups$tests$);
var $joeybright$gren_turso$Turso$Platform$Tokens$createResultDecoder = A4($gren_lang$core$Json$Decode$map3, F3(function(name, id, token) {
			return { id: id, name: name, token: token };
		}), A2($gren_lang$core$Json$Decode$field, 'name', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'id', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'token', $gren_lang$core$Json$Decode$string));
var $joeybright$gren_turso$Turso$Platform$Tokens$create = function(_v0) {
	var permission = _v0.permission;
	var token = _v0.token;
	var createdTokenName = _v0.createdTokenName;
	return $gren_lang$node$HttpClient$send$(permission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Tokens$createResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + token, $gren_lang$node$HttpClient$post('https://api.turso.tech/v1/auth/api-tokens/' + createdTokenName))));
};
var $joeybright$gren_turso$Turso$Platform$Tokens$listResultDecoder = A2($gren_lang$core$Json$Decode$map, function(tokens) {
		return { tokens: tokens };
	}, A2($gren_lang$core$Json$Decode$field, 'tokens', $gren_lang$core$Json$Decode$array(A3($gren_lang$core$Json$Decode$map2, F2(function(name, id) {
						return { id: id, name: name };
					}), A2($gren_lang$core$Json$Decode$field, 'name', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'id', $gren_lang$core$Json$Decode$string)))));
var $joeybright$gren_turso$Turso$Platform$Tokens$list = function(_v0) {
	var permission = _v0.permission;
	var token = _v0.token;
	return $gren_lang$node$HttpClient$send$(permission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Tokens$listResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + token, $gren_lang$node$HttpClient$get('https://api.turso.tech/v1/auth/api-tokens'))));
};
var $joeybright$gren_turso$Turso$Platform$Tokens$revokeResultDecoder = A2($gren_lang$core$Json$Decode$map, function(token) {
		return { tokenName: token };
	}, A2($gren_lang$core$Json$Decode$field, 'token', $gren_lang$core$Json$Decode$string));
var $joeybright$gren_turso$Turso$Platform$Tokens$revoke = function(_v0) {
	var permission = _v0.permission;
	var tokenNameToRevoke = _v0.tokenNameToRevoke;
	var token = _v0.token;
	return $gren_lang$node$HttpClient$send$(permission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Tokens$revokeResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + token, $gren_lang$node$HttpClient$request$($gren_lang$node$HttpServer$DELETE, 'https://api.turso.tech/v1/auth/api-tokens/' + tokenNameToRevoke))));
};
var $joeybright$gren_turso$Turso$Platform$Tokens$validateResultDecoder = A2($gren_lang$core$Json$Decode$map, function(exp) {
		return { exp: exp };
	}, A2($gren_lang$core$Json$Decode$field, 'exp', $gren_lang$core$Json$Decode$int));
var $joeybright$gren_turso$Turso$Platform$Tokens$validate = function(_v0) {
	var permission = _v0.permission;
	var token = _v0.token;
	return $gren_lang$node$HttpClient$send$(permission, $gren_lang$node$HttpClient$expectJson$($joeybright$gren_turso$Turso$Platform$Tokens$validateResultDecoder, $gren_lang$node$HttpClient$withHeader$('Authorization', 'Bearer ' + token, $gren_lang$node$HttpClient$get('https://api.turso.tech/v1/auth/validate'))));
};
var $author$project$Tests$Turso$Platform$Tokens$tests$ = function(connection, _v0) {
	var _v1 = connection;
	var httpPermission = _v1.httpPermission;
	var accessToken = _v1.accessToken;
	var organizationSlug = _v1.organizationSlug;
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the `Turso.Platform.Tokens` module', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($gren_lang$core$Crypto$getSecureContext, 'Await secure context for Crypto module functions', function(secureContext) {
				return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($gren_lang$core$Crypto$randomUuidV4(secureContext), 'Await generating a random token name value', function(randomUuid) {
						var testTokenName = 'gren-test-token-' + randomUuid;
						return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Tokens$create({ createdTokenName: testTokenName, permission: httpPermission, token: accessToken }), 'Await the creation of a new token', function(createdTokenResponse) {
								return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after getting a created token', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The name of the created token matches the name passed', function(_v2) {
											return A2($gren_lang$test$Expect$equal, createdTokenResponse.data.name, testTokenName);
										}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Tokens$list({ permission: httpPermission, token: accessToken }), 'Await a list of created tokens', function(tokenListResponse) {
											return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after getting the token list', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The newly created token is in the retrived list of tokens', function(_v3) {
														return A2($gren_lang$test$Expect$equal, true, A3($gren_lang$core$Array$foldl, F2(function(_v4, acc) {
																		var name = _v4.name;
																		return (acc === true) ? true : (_Utils_eq(name, testTokenName) ? true : false);
																	}), false, tokenListResponse.data.tokens));
													}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Tokens$validate({ permission: httpPermission, token: createdTokenResponse.data.token }), 'Await validating the given token', function(_v5) {
														return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after validating the given token', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The given token should be valid', function(_v6) {
																	return $gren_lang$test$Expect$pass;
																}), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($joeybright$gren_turso$Turso$Platform$Tokens$revoke({ permission: httpPermission, token: accessToken, tokenNameToRevoke: createdTokenResponse.data.name }), 'Await deleting the created token to clean up test data', function(revokeTokenResponse) {
																	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$test$('The name of the deleted token equals the generated token name', function(_v7) {
																			return A2($gren_lang$test$Expect$equal, revokeTokenResponse.data.tokenName, testTokenName);
																		});
																}) ]);
													}) ]);
										}) ]);
							});
					});
			}) ]);
};
var $author$project$Tests$Turso$Platform$Tokens$tests = F2($author$project$Tests$Turso$Platform$Tokens$tests$);
var $author$project$Tests$Turso$Platform$tests = function(_v0) {
	var httpPermission = _v0.httpPermission;
	var token = _v0.token;
	var group = _v0.group;
	var org = _v0.org;
	var connection = { accessToken: token, httpPermission: httpPermission, organizationSlug: org };
	return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($gren_lang$core$Crypto$getSecureContext, 'Awaiting secure context', function(secureContext) {
			return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($gren_lang$core$Crypto$randomUuidV4(secureContext), 'Awaiting generation of a random UUID', function(randomUuid) {
					return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('All tests', [ $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests for the Turso Platform API', [ $author$project$Tests$Turso$Platform$Databases$tests$(connection, { group: group, randomUuid: randomUuid }, F2(function(config, cleanupTests) {
										return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('Tests after creating a ', [ $author$project$Tests$Turso$Db$tests$(config.databaseConnection, { tableName: config.tableName }), $blaix$gren_effectful_tests_node$Test$Runner$Effectful$await$($gren_lang$core$Process$sleep(3000), 'Awaiting sleep', function(_v1) {
													return cleanupTests;
												}) ]);
									})), $author$project$Tests$Turso$Platform$Groups$tests$(connection, group), $author$project$Tests$Turso$Platform$Tokens$tests$(connection, {  }) ]) ]);
				});
		});
};
var $author$project$Main$main = $gren_lang$node$Node$defineSimpleProgram(function(env) {
		return $gren_lang$node$Init$await$($gren_lang$node$HttpClient$initialize, function(httpClientPermission) {
				var cliResult = $gren_lang$compiler_node$CLI$Parser$run$($gren_lang$core$Array$dropFirst$(2, env.args), $author$project$Main$cliConfig);
				if ((((cliResult.$ === 'Success') && (cliResult.a.token.$ === 'Just')) && (cliResult.a.group.$ === 'Just')) && (cliResult.a.org.$ === 'Just')) {
					var _v1 = cliResult.a;
					var token = _v1.token.a;
					var group = _v1.group.a;
					var org = _v1.org.a;
					return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$run$(env, $author$project$Tests$Turso$Platform$tests({ group: group, httpPermission: httpClientPermission, org: org, token: token }));
				} else {
					return $blaix$gren_effectful_tests_node$Test$Runner$Effectful$run$(env, $blaix$gren_effectful_tests_node$Test$Runner$Effectful$describe$('No tests run', [  ]));
				}
			});
	});
_Platform_export({'Main':{'init':$author$project$Main$main($gren_lang$core$Json$Decode$succeed({  }))}});}(this.module ? this.module.exports : this));
this.Gren.Main.init({});
}
catch (e)
{
console.error(e);
}
